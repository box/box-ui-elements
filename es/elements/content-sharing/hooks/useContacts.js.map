{"version":3,"file":"useContacts.js","names":["React","noop","API","FIELD_NAME","FIELD_PERMISSIONS","useContacts","api","itemID","options","getContacts","setGetContacts","useState","handleSuccess","handleError","transformGroups","transformUsers","useEffect","resolveAPICall","resolve","response","transformFn","entriesExist","entries","length","emptyEntries","updatedGetContactsFn","filterTerm","getUsers","Promise","getMarkerBasedUsersAPI","getUsersInEnterprise","filter_term","getGroups","getMarkerBasedGroupsAPI","getGroupsInEnterprise","fields","toString","all","then","contactArrays"],"sources":["../../../../src/elements/content-sharing/hooks/useContacts.js"],"sourcesContent":["// @flow\n\nimport * as React from 'react';\nimport noop from 'lodash/noop';\nimport API from '../../../api';\nimport { FIELD_NAME, FIELD_PERMISSIONS } from '../../../constants';\nimport type { GroupCollection, GroupMini, UserCollection, UserMini } from '../../../common/types/core';\nimport type { ContentSharingHooksOptions, GetContactsFnType } from '../types';\n\n/**\n * Generate the getContacts() function, which is used for retrieving potential collaborators in the USM.\n *\n * @param {API} api\n * @param {string} itemID\n * @param {ContentSharingHooksOptions} options\n * @returns {GetContactsFnType | null}\n */\nfunction useContacts(api: API, itemID: string, options: ContentSharingHooksOptions): GetContactsFnType | null {\n    const [getContacts, setGetContacts] = React.useState<null | GetContactsFnType>(null);\n    const { handleSuccess = noop, handleError = noop, transformGroups, transformUsers } = options;\n\n    React.useEffect(() => {\n        if (getContacts) return;\n\n        const resolveAPICall = (\n            resolve: (result: Array<Object>) => void,\n            response: GroupCollection | UserCollection,\n            transformFn: ?Function,\n        ) => {\n            handleSuccess(response);\n            // A successful API call will always return an entries array, but we still need these checks for Flow purposes\n            const entriesExist = response && response.entries && response.entries.length;\n            if (transformFn && entriesExist) {\n                return resolve(transformFn(response));\n            }\n            const emptyEntries: Array<any> = [];\n            return resolve(response && response.entries ? response.entries : emptyEntries);\n        };\n\n        const updatedGetContactsFn: GetContactsFnType = () => (filterTerm: string) => {\n            const getUsers = new Promise((resolve: (result: Array<UserMini>) => void) => {\n                api.getMarkerBasedUsersAPI(false).getUsersInEnterprise(\n                    itemID,\n                    (response: UserCollection) => resolveAPICall(resolve, response, transformUsers),\n                    handleError,\n                    { filter_term: filterTerm },\n                );\n            });\n            const getGroups = new Promise((resolve: (result: Array<GroupMini>) => void) => {\n                api.getMarkerBasedGroupsAPI(false).getGroupsInEnterprise(\n                    itemID,\n                    (response: GroupCollection) => resolveAPICall(resolve, response, transformGroups),\n                    handleError,\n                    {\n                        fields: [FIELD_NAME, FIELD_PERMISSIONS].toString(),\n                        filter_term: filterTerm,\n                    },\n                );\n            });\n            return Promise.all([getUsers, getGroups]).then(contactArrays => [...contactArrays[0], ...contactArrays[1]]);\n        };\n        setGetContacts(updatedGetContactsFn);\n    }, [api, getContacts, handleError, handleSuccess, itemID, transformGroups, transformUsers]);\n\n    return getContacts;\n}\n\nexport default useContacts;\n"],"mappings":"AAEA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAOC,GAAG,MAAM,cAAc;AAC9B,SAASC,UAAU,EAAEC,iBAAiB,QAAQ,oBAAoB;AAIlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,GAAQ,EAAEC,MAAc,EAAEC,OAAmC,EAA4B;EAC1G,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGV,KAAK,CAACW,QAAQ,CAA2B,IAAI,CAAC;EACpF,MAAM;IAAEC,aAAa,GAAGX,IAAI;IAAEY,WAAW,GAAGZ,IAAI;IAAEa,eAAe;IAAEC;EAAe,CAAC,GAAGP,OAAO;EAE7FR,KAAK,CAACgB,SAAS,CAAC,MAAM;IAClB,IAAIP,WAAW,EAAE;IAEjB,MAAMQ,cAAc,GAAGA,CACnBC,OAAwC,EACxCC,QAA0C,EAC1CC,WAAsB,KACrB;MACDR,aAAa,CAACO,QAAQ,CAAC;MACvB;MACA,MAAME,YAAY,GAAGF,QAAQ,IAAIA,QAAQ,CAACG,OAAO,IAAIH,QAAQ,CAACG,OAAO,CAACC,MAAM;MAC5E,IAAIH,WAAW,IAAIC,YAAY,EAAE;QAC7B,OAAOH,OAAO,CAACE,WAAW,CAACD,QAAQ,CAAC,CAAC;MACzC;MACA,MAAMK,YAAwB,GAAG,EAAE;MACnC,OAAON,OAAO,CAACC,QAAQ,IAAIA,QAAQ,CAACG,OAAO,GAAGH,QAAQ,CAACG,OAAO,GAAGE,YAAY,CAAC;IAClF,CAAC;IAED,MAAMC,oBAAuC,GAAGA,CAAA,KAAOC,UAAkB,IAAK;MAC1E,MAAMC,QAAQ,GAAG,IAAIC,OAAO,CAAEV,OAA0C,IAAK;QACzEZ,GAAG,CAACuB,sBAAsB,CAAC,KAAK,CAAC,CAACC,oBAAoB,CAClDvB,MAAM,EACLY,QAAwB,IAAKF,cAAc,CAACC,OAAO,EAAEC,QAAQ,EAAEJ,cAAc,CAAC,EAC/EF,WAAW,EACX;UAAEkB,WAAW,EAAEL;QAAW,CAC9B,CAAC;MACL,CAAC,CAAC;MACF,MAAMM,SAAS,GAAG,IAAIJ,OAAO,CAAEV,OAA2C,IAAK;QAC3EZ,GAAG,CAAC2B,uBAAuB,CAAC,KAAK,CAAC,CAACC,qBAAqB,CACpD3B,MAAM,EACLY,QAAyB,IAAKF,cAAc,CAACC,OAAO,EAAEC,QAAQ,EAAEL,eAAe,CAAC,EACjFD,WAAW,EACX;UACIsB,MAAM,EAAE,CAAChC,UAAU,EAAEC,iBAAiB,CAAC,CAACgC,QAAQ,CAAC,CAAC;UAClDL,WAAW,EAAEL;QACjB,CACJ,CAAC;MACL,CAAC,CAAC;MACF,OAAOE,OAAO,CAACS,GAAG,CAAC,CAACV,QAAQ,EAAEK,SAAS,CAAC,CAAC,CAACM,IAAI,CAACC,aAAa,IAAI,CAAC,GAAGA,aAAa,CAAC,CAAC,CAAC,EAAE,GAAGA,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/G,CAAC;IACD7B,cAAc,CAACe,oBAAoB,CAAC;EACxC,CAAC,EAAE,CAACnB,GAAG,EAAEG,WAAW,EAAEI,WAAW,EAAED,aAAa,EAAEL,MAAM,EAAEO,eAAe,EAAEC,cAAc,CAAC,CAAC;EAE3F,OAAON,WAAW;AACtB;AAEA,eAAeJ,WAAW","ignoreList":[]}