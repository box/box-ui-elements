{"version":3,"file":"metadataTaxonomyFetcher.js","names":["metadataTaxonomyFetcher","api","fileId","scope","templateKey","fieldKey","level","options","metadataOptions","getMetadataAPI","getMetadataOptions","marker","_objectSpread","entries","map","metadataOption","value","id","displayValue","display_name","displayName","parentId","nodePath","deprecated","ancestors","_ref","rest","_objectWithoutProperties","_excluded","selectable","total_result_count","undefined","totalResultCount","limit","metadataTaxonomyNodeAncestorsFetcher","fileID","taxonomyKey","nodeID","metadataTaxonomy","metadataTaxonomyNode","Promise","all","getMetadataTaxonomy","getMetadataTaxonomyNode","levels","levelsMap","Map","item","levelData","levelName","description","set","levelValue","length","ancestor","get","hydratedLevels","Array","from","values","filter"],"sources":["../../../../src/elements/content-sidebar/fetchers/metadataTaxonomyFetcher.ts"],"sourcesContent":["import { TreeQueryInput, TreeOptionType, FetcherResponse } from '@box/combobox-with-api';\nimport type API from '../../../api';\nimport type { MetadataOptionEntry } from '../../../common/types/metadata';\n\nexport const metadataTaxonomyFetcher = async (\n    api: API,\n    fileId: string,\n    scope: string,\n    templateKey: string,\n    fieldKey: string,\n    level: number,\n    options: TreeQueryInput,\n): Promise<FetcherResponse<TreeOptionType>> => {\n    const metadataOptions = await api\n        .getMetadataAPI(false)\n        .getMetadataOptions(fileId, scope, templateKey, fieldKey, level, options);\n    const { marker = null } = options;\n\n    return {\n        options: metadataOptions.entries.map((metadataOption: MetadataOptionEntry) => ({\n            value: metadataOption.id,\n            displayValue: metadataOption.display_name || metadataOption.displayName,\n            level: metadataOption.level,\n            parentId: metadataOption.parentId,\n            nodePath: metadataOption.nodePath,\n            deprecated: metadataOption.deprecated,\n            ancestors: metadataOption.ancestors?.map(({display_name, displayName, ...rest}) => ({...rest, displayName: display_name || displayName })),\n            selectable: metadataOption.selectable,\n        })),\n        marker,\n        ...(metadataOptions.total_result_count !== undefined && { totalResultCount: metadataOptions.total_result_count }),\n        ...(metadataOptions.limit !== undefined && { limit: metadataOptions.limit }),\n    } as FetcherResponse<TreeOptionType>;\n};\n\ntype HydratedMetadataTaxonomyLevel = {\n    level: number;\n    levelName: string;\n    description: string;\n    levelValue: string;\n    id: string;\n};\n\nexport const metadataTaxonomyNodeAncestorsFetcher = async (\n    api: API,\n    fileID: string,\n    scope: string,\n    taxonomyKey: string,\n    nodeID: string,\n): Promise<HydratedMetadataTaxonomyLevel[]> => {\n    const [metadataTaxonomy, metadataTaxonomyNode] = await Promise.all([\n        api.getMetadataAPI(false).getMetadataTaxonomy(fileID, scope, taxonomyKey),\n        api.getMetadataAPI(false).getMetadataTaxonomyNode(fileID, scope, taxonomyKey, nodeID, true),\n    ]);\n\n    if (!metadataTaxonomy?.levels) {\n        return [];\n    }\n\n    // Create a hashmap of levels to easily hydrate with data from metadataTaxonomyNode\n    const levelsMap = new Map();\n    for (const item of metadataTaxonomy.levels) {\n        const levelData = {\n            level: item.level,\n            levelName: item.displayName || item.display_name,\n            description: item.description,\n        };\n\n        // If the level matches the metadataTaxonomyNode level, hydrate the level with the node data\n        if (metadataTaxonomyNode.level === item.level) {\n            levelsMap.set(item.level, {\n                ...levelData,\n                id: metadataTaxonomyNode.id,\n                levelValue: metadataTaxonomyNode.displayName || metadataTaxonomyNode.display_name,\n            });\n            // If the level is not the metadataTaxonomyNode level, just add the level data\n        } else {\n            levelsMap.set(item.level, levelData);\n        }\n    }\n    // Hydrate the levels with the ancestors data from the metadataTaxonomyNode\n    if (metadataTaxonomyNode.ancestors?.length) {\n        for (const ancestor of metadataTaxonomyNode.ancestors) {\n            const levelData = levelsMap.get(ancestor.level);\n\n            if (levelData) {\n                levelsMap.set(ancestor.level, { ...levelData, levelValue: ancestor.displayName || ancestor.display_name, id: ancestor.id });\n            }\n        }\n    }\n\n    // Filter out levels that were not hydrated by metadataTaxonomyNode\n    const hydratedLevels = Array.from(levelsMap.values()).filter(level => !!level.id);\n\n    // Return the hydrated levels as an array\n    return hydratedLevels;\n};\n"],"mappings":"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","ignoreList":[]}