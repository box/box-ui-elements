{"version":3,"file":"metadata.js","names":["FIELD_TYPE_DATE","FIELD_TYPE_ENUM","FIELD_TYPE_FLOAT","FIELD_TYPE_MULTISELECT","FIELD_TYPE_STRING","FIELD_TYPE_TAXONOMY"],"sources":["../../../src/common/types/metadata.js"],"sourcesContent":["// @flow strict\nimport {\n    FIELD_TYPE_DATE,\n    FIELD_TYPE_ENUM,\n    FIELD_TYPE_FLOAT,\n    FIELD_TYPE_MULTISELECT,\n    FIELD_TYPE_STRING,\n    FIELD_TYPE_TAXONOMY,\n} from '../../features/metadata-instance-fields/constants';\nimport type { SkillCards } from './skills';\n\ntype MetadataFieldType =\n    | typeof FIELD_TYPE_DATE\n    | typeof FIELD_TYPE_ENUM\n    | typeof FIELD_TYPE_FLOAT\n    | typeof FIELD_TYPE_MULTISELECT\n    | typeof FIELD_TYPE_STRING\n    | typeof FIELD_TYPE_TAXONOMY;\n\ntype MetadataTemplateFieldOption = {\n    id?: string,\n    key: string,\n};\n\nexport type TaxonomyLevel = {\n    description: string,\n    displayName: string,\n    level: number,\n};\n\ntype MetadataTemplateField = {\n    description?: string,\n    displayName: string,\n    hidden?: boolean,\n    id: string,\n    isHidden?: boolean,\n    key: string, // V2\n    options?: Array<MetadataTemplateFieldOption>, // V3\n    type: MetadataFieldType,\n    levels?: Array<TaxonomyLevel>,\n    namespace?: string,\n    taxonomyKey?: string,\n    taxonomy_key?: string,\n};\n\ntype MetadataTemplate = {\n    displayName?: string,\n    fields?: Array<MetadataTemplateField>,\n    hidden?: boolean,\n    id: string,\n    isHidden?: boolean,\n    scope: string, // V2\n    templateKey: string, // V3\n};\n\ntype MetadataTemplateSchemaResponse = {\n    data?: MetadataTemplate,\n};\n\ntype MetadataSkillsTemplate = {\n    archivedItemTemplate?: {\n        archiveDate: string,\n    },\n    boxSkillsCards?: SkillCards,\n};\n\n// $FlowFixMe flow strict doesn't like use of \"any\"\ntype MetadataFieldValue = string | number | Array<any>;\n\ntype MetadataFields = { [string]: MetadataFieldValue };\n\ntype MetadataQueryInstanceTypeField = {\n    displayName: string,\n    key: string,\n    options?: MetadataTemplateFieldOption,\n    type: string,\n    value: ?MetadataFieldValue,\n};\n\ntype MetadataQueryInstanceTemplate = {\n    fields: Array<MetadataQueryInstanceTypeField>,\n    id: string,\n};\n\ntype MetadataType = {\n    enterprise?: MetadataQueryInstanceTemplate,\n    global?: MetadataSkillsTemplate,\n};\n\ntype MetadataCascadePolicyConfiguration = {\n    agent: string,\n};\n\ntype MetadataCascadePolicy = {\n    canEdit?: boolean,\n    id?: string,\n    cascadePolicyType?: string,\n    cascadePolicyConfiguration?: MetadataCascadePolicyConfiguration,\n};\n\ntype MetadataCascadingPolicyData = {\n    id?: string,\n    isEnabled: boolean,\n    overwrite: boolean,\n    cascadePolicyConfiguration: MetadataCascadePolicyConfiguration | null,\n};\n\ntype MetadataInstance = {\n    canEdit: boolean,\n    cascadePolicy?: MetadataCascadePolicy,\n    data: MetadataFields,\n    id: string,\n};\n\ntype MetadataInstanceV2 = {\n    $canEdit: boolean,\n    $id: string,\n    $parent: string,\n    $scope: string,\n    $template: string,\n    $type: string,\n    $typeVersion: number,\n    $version: number,\n};\n\ntype MetadataEditor = {\n    hasError?: boolean,\n    instance: MetadataInstance,\n    isDirty?: boolean,\n    template: MetadataTemplate,\n};\n\ntype MetadataSuggestion = {\n    $scope: string,\n    $templateKey: string,\n    suggestions: { [key: string]: string | number | string[] },\n};\n\ntype MetadataOptionEntryAncestor = {\n    id: string,\n    display_name: string,\n    level: string,\n};\n\ntype MetadataOptionEntry = {\n    id: string,\n    display_name: string,\n    level: number,\n    ancestors: MetadataOptionEntryAncestor[],\n    deprecated: boolean,\n    selectable: boolean,\n};\n\ntype MetadataOptions = {\n    entries: MetadataOptionEntry[],\n    next_marker: string | null,\n    result_count: number,\n};\n\ntype MetadataTemplateInstanceField = {\n    description?: string,\n    displayName?: string,\n    hidden?: boolean,\n    id?: string,\n    key: string, // V2\n    levels?: Array<TaxonomyLevel>,\n    options?: Array<MetadataTemplateFieldOption>, // V3\n    type: MetadataFieldType,\n    value: MetadataFieldValue,\n};\n\ntype MetadataTemplateInstance = {\n    canEdit: boolean,\n    displayName?: string,\n    hidden?: boolean,\n    id: string,\n    fields: MetadataTemplateInstanceField[],\n    scope: string,\n    templateKey: string,\n    type: string,\n};\n\nexport type {\n    MetadataTemplateInstanceField,\n    MetadataTemplateInstance,\n    MetadataFieldType,\n    MetadataTemplateFieldOption,\n    MetadataTemplateField,\n    MetadataTemplate,\n    MetadataTemplateSchemaResponse,\n    MetadataFieldValue,\n    MetadataFields,\n    MetadataQueryInstanceTypeField,\n    MetadataType,\n    MetadataCascadePolicy,\n    MetadataCascadePolicyConfiguration,\n    MetadataCascadingPolicyData,\n    MetadataInstanceV2,\n    MetadataEditor,\n    MetadataSuggestion,\n    MetadataOptions,\n};\n"],"mappings":"AACA,SACIA,eAAe,EACfC,eAAe,EACfC,gBAAgB,EAChBC,sBAAsB,EACtBC,iBAAiB,EACjBC,mBAAmB,QAChB,mDAAmD;;AA0D1D","ignoreList":[]}