{"version":3,"file":"defaultInputParser.js","names":["uniqBy","escapeRegExp","parseCSV","defaultInputParser","inputValue","options","selectedOptions","mappedOptions","inputTokens","map","inputToken","trimmedInputToken","replace","escapedInputToken","regex","RegExp","existingOption","find","displayText","value","test","String","mappedOption","filter","some","selectedOption"],"sources":["../../../src/components/pill-selector-dropdown/defaultInputParser.js"],"sourcesContent":["// @flow\nimport uniqBy from 'lodash/uniqBy';\nimport escapeRegExp from 'lodash/escapeRegExp';\n\nimport parseCSV from '../../utils/parseCSV';\n\nimport type { Option } from './flowTypes';\n\n// Custom input parser for the PillSelectorDropdownField that automatically maps\n// a list of comma separated values to their respective Option objects. The parser\n// will try to find exact but case-insenstive matches using the option's displayText\n// property. If a token does not match displayText, the parser will also try to match\n// the string representation of the value property. This last match is useful for country\n// codes and other similar use cases.\nfunction defaultInputParser(inputValue: string, options: Array<Option>, selectedOptions: Array<Option>): Array<Option> {\n    let mappedOptions;\n    const inputTokens = parseCSV(inputValue);\n\n    mappedOptions = inputTokens.map((inputToken: string): Option => {\n        const trimmedInputToken = inputToken.replace(/\\s/g, '');\n        const escapedInputToken = escapeRegExp(trimmedInputToken);\n        const regex = new RegExp(`^${escapedInputToken}$`, 'i');\n\n        const existingOption = options.find(\n            ({ displayText, value }: Option) =>\n                // Match name without whitespace or commas\n                regex.test(displayText.replace(/\\s|,/g, '')) || regex.test(String(value)),\n        );\n        const mappedOption = existingOption || {\n            displayText: inputToken,\n            value: inputToken,\n        };\n        return mappedOption;\n    });\n    // Remove duplicate values\n    mappedOptions = uniqBy(mappedOptions, mappedOption => mappedOption.value);\n    // Remove previously selected values\n    mappedOptions = mappedOptions.filter(\n        mappedOption => !selectedOptions.some(selectedOption => mappedOption.value === selectedOption.value),\n    );\n    return mappedOptions;\n}\n\nexport default defaultInputParser;\n"],"mappings":"AACA,OAAOA,MAAM,MAAM,eAAe;AAClC,OAAOC,YAAY,MAAM,qBAAqB;AAE9C,OAAOC,QAAQ,MAAM,sBAAsB;AAI3C;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,UAAkB,EAAEC,OAAsB,EAAEC,eAA8B,EAAiB;EACnH,IAAIC,aAAa;EACjB,MAAMC,WAAW,GAAGN,QAAQ,CAACE,UAAU,CAAC;EAExCG,aAAa,GAAGC,WAAW,CAACC,GAAG,CAAEC,UAAkB,IAAa;IAC5D,MAAMC,iBAAiB,GAAGD,UAAU,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IACvD,MAAMC,iBAAiB,GAAGZ,YAAY,CAACU,iBAAiB,CAAC;IACzD,MAAMG,KAAK,GAAG,IAAIC,MAAM,CAAC,IAAIF,iBAAiB,GAAG,EAAE,GAAG,CAAC;IAEvD,MAAMG,cAAc,GAAGX,OAAO,CAACY,IAAI,CAC/B,CAAC;MAAEC,WAAW;MAAEC;IAAc,CAAC;IAC3B;IACAL,KAAK,CAACM,IAAI,CAACF,WAAW,CAACN,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,IAAIE,KAAK,CAACM,IAAI,CAACC,MAAM,CAACF,KAAK,CAAC,CAChF,CAAC;IACD,MAAMG,YAAY,GAAGN,cAAc,IAAI;MACnCE,WAAW,EAAER,UAAU;MACvBS,KAAK,EAAET;IACX,CAAC;IACD,OAAOY,YAAY;EACvB,CAAC,CAAC;EACF;EACAf,aAAa,GAAGP,MAAM,CAACO,aAAa,EAAEe,YAAY,IAAIA,YAAY,CAACH,KAAK,CAAC;EACzE;EACAZ,aAAa,GAAGA,aAAa,CAACgB,MAAM,CAChCD,YAAY,IAAI,CAAChB,eAAe,CAACkB,IAAI,CAACC,cAAc,IAAIH,YAAY,CAACH,KAAK,KAAKM,cAAc,CAACN,KAAK,CACvG,CAAC;EACD,OAAOZ,aAAa;AACxB;AAEA,eAAeJ,kBAAkB","ignoreList":[]}