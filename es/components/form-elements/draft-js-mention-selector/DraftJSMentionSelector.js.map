{"version":3,"file":"DraftJSMentionSelector.js","names":["React","CompositeDecorator","EditorState","Modifier","SelectionState","ContentState","noop","DraftJSMentionSelectorCore","DraftMentionItem","DraftTimestampItem","FormInput","messages","Toggle","UNEDITABLE_TIMESTAMP_TEXT","convertSecondsToHMMSS","mentionStrategy","contentBlock","callback","contentState","findEntityRanges","character","entityKey","getEntity","ret","getType","timestampStrategy","hasEntityKey","entityType","timeStampEntityFound","DraftJSMentionSelector","Component","constructor","props","_defineProperty","timestampLabel","trim","editorState","forceOn","currentContent","getCurrentContent","updatedContent","newIsTimestampToggledOn","isTimestampToggledOn","state","timestampLengthIncludingSpace","getTimestampLength","isTimestampEntityPresent","timestamp","timestampInMilliseconds","getVideoTimestamp","fileVersionId","timestampText","contentWithTimestampEntity","createEntity","selectionAtStart","createEmpty","getFirstBlock","getKey","merge","anchorOffset","focusOffset","insertText","selectionWithTimestamp","length","getLastCreatedEntityKey","applyEntity","selectionToRemove","replaceText","cursorOffset","finalSelection","newEditorState","push","forceSelection","setState","handleChange","event","validateOnBlur","containerEl","relatedTarget","Node","contains","checkValidity","onFocus","block","timestampLength","characterList","getCharacterList","i","size","char","get","entity","nextEditorState","internalEditorState","onChange","getIsVideoTimestampEnabled","firstBlock","timestampEntityFound","firstChar","newState","isTouched","error","getErrorFromValidityState","handleValidityStateUpdateHandler","mediaDashContainer","document","querySelector","video","currentTime","totalSeconds","Math","floor","timestampToDisplay","compositeDecorator","strategy","component","contacts","getDerivedStateFromProps","nextProps","componentDidMount","externalEditorState","currentEditorState","isTimeStampEntityPresent","getIsTimestampEntityPresent","componentDidUpdate","prevProps","prevState","prevInternalEditorState","prevEditorStateFromProps","isRequired","prevIsRequiredFromProps","prevEditorState","getDerivedStateFromEditorState","checkValidityIfAllowed","toggleTimestamp","previousEditorState","isPreviousEditorStateEmpty","isEditorStateEmpty","isCurrentEditorStateEmpty","isNewEditorState","isEditorStateDirty","text","getPlainText","lastChangeType","getLastChangeType","maxLength","minLength","valueMissing","tooShort","tooLong","render","className","contactsLoaded","hideLabel","isDisabled","label","description","mentionTriggers","name","onMention","placeholder","selectorRow","startMentionMessage","onReturn","timestampToggledOn","handleBlur","handleFocus","getDecorator","set","decorator","createElement","ref","onValidityStateUpdate","onBlur","isOn"],"sources":["../../../../src/components/form-elements/draft-js-mention-selector/DraftJSMentionSelector.js"],"sourcesContent":["// @flow\nimport * as React from 'react';\nimport { CompositeDecorator, EditorState, Modifier, SelectionState, ContentState } from 'draft-js';\nimport noop from 'lodash/noop';\n\nimport DraftJSMentionSelectorCore from './DraftJSMentionSelectorCore';\nimport DraftMentionItem from './DraftMentionItem';\nimport DraftTimestampItem from './DraftTimestampItem';\nimport FormInput from '../form/FormInput';\nimport * as messages from '../input-messages';\nimport type { SelectorItems } from '../../../common/types/core';\nimport Toggle from '../../toggle/Toggle';\nimport { UNEDITABLE_TIMESTAMP_TEXT } from './utils';\nimport { convertSecondsToHMMSS } from '../../../utils/timestamp';\n\ntype videoTimestamp = {\n    timestamp: string,\n    timestampInMilliseconds: number,\n};\n\n/**\n * Scans a Draft ContentBlock for entity ranges, so they can be annotated\n * @see docs at {@link https://draftjs.org/docs/advanced-topics-decorators.html#compositedecorator}\n * @param {ContentBlock} contentBlock\n * @param {function} callback\n * @param {ContentState} contentState\n */\nconst mentionStrategy = (contentBlock, callback, contentState) => {\n    contentBlock.findEntityRanges(character => {\n        const entityKey = character.getEntity();\n        const ret = entityKey !== null && contentState.getEntity(entityKey).getType() === 'MENTION';\n        return ret;\n    }, callback);\n};\n\n/**\n * Scans a Draft ContentBlock for timestamp entity ranges\n * @see docs at {@link https://draftjs.org/docs/advanced-topics-decorators.html#compositedecorator}\n * @param {ContentBlock} contentBlock\n * @param {function} callback\n * @param {ContentState} contentState\n */\nconst timestampStrategy = (contentBlock: any, callback: (start: number, end: number) => void, contentState: any) => {\n    if (!contentBlock || !contentState) {\n        return;\n    }\n    contentBlock.findEntityRanges(character => {\n        const entityKey = character.getEntity();\n        const hasEntityKey = entityKey !== null;\n        // $FlowFixMe\n        const entityType = hasEntityKey && contentState?.getEntity(entityKey)?.getType();\n        const timeStampEntityFound = entityType === UNEDITABLE_TIMESTAMP_TEXT;\n        return timeStampEntityFound;\n    }, callback);\n};\n\ntype Props = {\n    className?: string,\n    contacts: SelectorItems<>,\n    contactsLoaded?: boolean,\n    description?: React.Node,\n    editorState?: EditorState,\n    fileVersionId?: string,\n    hideLabel?: boolean,\n    isDisabled?: boolean,\n    isRequired?: boolean,\n    label: React.Node,\n    maxLength?: number,\n    mentionTriggers?: Array<string>,\n    minLength?: number,\n    name: string,\n    onChange: Function,\n    onFocus?: Function,\n    onMention?: Function,\n    onReturn?: Function,\n    placeholder?: string,\n    selectorRow?: React.Element<any>,\n    startMentionMessage?: React.Node,\n    timestampLabel?: string | null,\n    validateOnBlur?: boolean,\n};\n\ntype State = {\n    contacts: SelectorItems<>,\n    error: ?Object,\n    internalEditorState: ?EditorState,\n    isTouched: boolean,\n    isTimestampToggledOn: boolean,\n};\n\nclass DraftJSMentionSelector extends React.Component<Props, State> {\n    compositeDecorator: CompositeDecorator;\n\n    static defaultProps = {\n        isRequired: false,\n        onChange: noop,\n        validateOnBlur: true,\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.compositeDecorator = new CompositeDecorator([\n            {\n                strategy: mentionStrategy,\n                component: DraftMentionItem,\n            },\n            {\n                strategy: timestampStrategy,\n                component: DraftTimestampItem,\n            },\n        ]);\n\n        // @NOTE:\n        // This component might be either own its EditorState (in which case it lives in `this.state.internalEditorState`)\n        // or be a controlled component whose EditorState is passed in via the `editorState` prop.\n        // If `props.editorState` is set, `internalEditorState` is `null`,\n        // otherwise we initialize it here\n        this.state = {\n            contacts: [],\n            isTouched: false,\n            internalEditorState: props.editorState ? null : EditorState.createEmpty(this.compositeDecorator),\n            error: null,\n            isTimestampToggledOn: false,\n        };\n    }\n\n    static getDerivedStateFromProps(nextProps: Props) {\n        const { contacts } = nextProps;\n        return contacts ? { contacts } : null;\n    }\n\n    componentDidMount() {\n        // if video timestamping is enabled we need to check if a timestamp entity is present in the editor state passed in via props\n        // and if it is then set the isTimestampToggledOn state to true. This will happen when the user is editing a comment\n        // that has a timestamp entity.\n        if (this.getIsVideoTimestampEnabled()) {\n            const { isTimestampToggledOn, internalEditorState } = this.state;\n            const { editorState: externalEditorState } = this.props;\n            const currentEditorState = internalEditorState || externalEditorState;\n            // if video timestamping is enabled and the editor state is being passed in check if a timestamp entity is present\n            // and if it is then set the isTimestampToggledOn state to true.\n            if (!isTimestampToggledOn && currentEditorState) {\n                const currentContent = currentEditorState.getCurrentContent();\n                const isTimeStampEntityPresent = this.getIsTimestampEntityPresent(currentContent);\n                if (isTimeStampEntityPresent) {\n                    this.setState({ isTimestampToggledOn: true });\n                }\n            }\n        }\n    }\n\n    componentDidUpdate(prevProps: Props, prevState: State) {\n        const { internalEditorState: prevInternalEditorState } = prevState;\n        const { internalEditorState } = this.state;\n        const { editorState: prevEditorStateFromProps, isRequired: prevIsRequiredFromProps } = prevProps;\n        const { editorState, isRequired } = this.props;\n\n        // Determine whether we're working with the internal editor state or\n        // external editor state passed in from props\n        const prevEditorState = prevInternalEditorState || prevEditorStateFromProps;\n        const currentEditorState = internalEditorState || editorState;\n\n        // Only handle isTouched state transitions and check validity if the\n        // editorState references are different. This is to avoid getting stuck\n        // in an infinite loop of checking validity because checkValidity always\n        // calls setState({ error })\n        if (prevEditorState && currentEditorState && prevEditorState !== currentEditorState) {\n            const newState = this.getDerivedStateFromEditorState(currentEditorState, prevEditorState);\n            if (newState) {\n                this.setState(newState, this.checkValidityIfAllowed);\n            } else {\n                this.checkValidityIfAllowed();\n            }\n        }\n\n        // if isRequired is false then the comment box will be closed and we want\n        // to make sure that isTimestampToggledOn is always set to false in this casee\n        if (this.getIsVideoTimestampEnabled() && isRequired !== prevIsRequiredFromProps && isRequired === false) {\n            this.setState({ isTimestampToggledOn: false });\n        }\n\n        // If timestamplabel is set and isRequired is true then force the timestamp\n        // to be added to the editor state as that is the specified default behavior for video comments\n        if (this.getIsVideoTimestampEnabled() && isRequired !== prevIsRequiredFromProps && isRequired === true) {\n            this.toggleTimestamp(currentEditorState, true);\n        }\n    }\n\n    getIsVideoTimestampEnabled = () => {\n        const { timestampLabel } = this.props;\n        return !!timestampLabel && timestampLabel.trim() !== '';\n    };\n\n    getDerivedStateFromEditorState(currentEditorState: EditorState, previousEditorState: EditorState) {\n        const isPreviousEditorStateEmpty = this.isEditorStateEmpty(previousEditorState);\n        const isCurrentEditorStateEmpty = this.isEditorStateEmpty(currentEditorState);\n        const isNewEditorState = isCurrentEditorStateEmpty && !isPreviousEditorStateEmpty;\n        const isEditorStateDirty = isPreviousEditorStateEmpty && !isCurrentEditorStateEmpty;\n\n        let newState = null;\n        // Detect case where controlled EditorState is created anew and empty.\n        // If next editorState is empty and the current editorState is not empty\n        // that means it is a new empty state and this component should not be marked dirty\n        if (isNewEditorState) {\n            newState = { isTouched: false, error: null };\n        } else if (isEditorStateDirty) {\n            // Detect case where controlled EditorState has been made dirty\n            // If the current editorState is empty and the next editorState is not\n            // empty then this is the first interaction so mark this component dirty\n            newState = { isTouched: true };\n        }\n\n        return newState;\n    }\n\n    toggleTimestamp = (editorState: ?EditorState, forceOn: boolean = false) => {\n        if (!editorState) return;\n        const currentContent = editorState.getCurrentContent();\n\n        let updatedContent;\n        let newIsTimestampToggledOn;\n        const { isTimestampToggledOn } = this.state;\n\n        // If timestamp is already prepended and forceOn is true, do not toggle it.\n        if (isTimestampToggledOn && forceOn) {\n            return;\n        }\n\n        const timestampLengthIncludingSpace = this.getTimestampLength(currentContent);\n        const isTimestampEntityPresent = timestampLengthIncludingSpace > 0;\n\n        // check if we need to toggle the timestamp on and that the timestamp entity is not already present in the content\n        if ((!isTimestampToggledOn || forceOn) && !isTimestampEntityPresent) {\n            // get the current timestamp\n            const { timestamp, timestampInMilliseconds } = this.getVideoTimestamp();\n            const { fileVersionId } = this.props;\n            const timestampText = `${timestamp}`;\n            // Create a new entity for the timestamp. It is immutable so it will not be editable. Adding\n            // timestampInMilliseconds, and fileVersionId to the entity data which will be used when the comment form is submitted\n            // and will be added to the text of the comment. This will let us filter out timetsamped comments based on version and also\n            // be able to click the timestamp button in comments in the sidebar and got to the proper place in the video.\n            // $FlowFixMe\n            const contentWithTimestampEntity = currentContent.createEntity(\n                UNEDITABLE_TIMESTAMP_TEXT, // Entity type\n                'IMMUTABLE',\n                { timestampInMilliseconds, fileVersionId },\n            );\n\n            // Create a selection at the very beginning of the input box for the timestamp\n            const selectionAtStart = SelectionState.createEmpty(\n                contentWithTimestampEntity.getFirstBlock().getKey(),\n            ).merge({\n                anchorOffset: 0,\n                focusOffset: 0,\n            });\n\n            // First insert the timestamp text followed by a space\n            updatedContent = Modifier.insertText(contentWithTimestampEntity, selectionAtStart, `${timestampText} `);\n\n            // Then select the timestamp text not including the space\n            const selectionWithTimestamp = SelectionState.createEmpty(updatedContent.getFirstBlock().getKey()).merge({\n                anchorOffset: 0,\n                focusOffset: timestampText.length,\n            });\n\n            // Get the entity key for the timestamp entity\n            const entityKey = contentWithTimestampEntity.getLastCreatedEntityKey();\n\n            // Apply the timestamp entity to selected timestamp text. This will ensure that the timestamp is uneditable and that\n            // the decorator will apply the proper styling to the timestamp.\n            updatedContent = Modifier.applyEntity(updatedContent, selectionWithTimestamp, entityKey);\n\n            newIsTimestampToggledOn = true;\n        } else {\n            // Create a selection range for the timestamp text and space so that we know what to remove and\n            // remove it from the beginning of the input box. This uses the timestsamp length that we calculated earlier.\n            const selectionToRemove = SelectionState.createEmpty(currentContent.getFirstBlock().getKey()).merge({\n                anchorOffset: 0,\n                focusOffset: timestampLengthIncludingSpace,\n            });\n\n            // Remove the timestamp text and space. No need for an entity key because we are not applying any entity to the text.\n            updatedContent = Modifier.replaceText(currentContent, selectionToRemove, '');\n            newIsTimestampToggledOn = false;\n        }\n\n        // Position cursor after the timestamp and space (if adding) or at the beginning (if removing)\n        const cursorOffset = newIsTimestampToggledOn ? timestampLengthIncludingSpace : 0;\n        // Create a selection that ensures the cursor is outside any entity. This is important because we want to ensure\n        // that the cursor is not inside the timestamp component when it is displayed\n        const finalSelection = SelectionState.createEmpty(updatedContent.getFirstBlock().getKey()).merge({\n            anchorOffset: cursorOffset,\n            focusOffset: cursorOffset,\n        });\n\n        // Create a new EditorState with the updated content\n        let newEditorState = EditorState.push(editorState, updatedContent, 'insert-characters');\n        // Apply selection first\n        newEditorState = EditorState.forceSelection(newEditorState, finalSelection);\n\n        // Update state with new timestamp status\n        this.setState({\n            isTimestampToggledOn: newIsTimestampToggledOn,\n        });\n\n        // handle the change in the editor state\n        this.handleChange(newEditorState);\n    };\n\n    checkValidityIfAllowed() {\n        const { validateOnBlur }: Props = this.props;\n\n        if (!validateOnBlur) {\n            this.checkValidity();\n        }\n    }\n\n    isEditorStateEmpty(editorState: EditorState): boolean {\n        const text = editorState.getCurrentContent().getPlainText().trim();\n        const lastChangeType = editorState.getLastChangeType();\n\n        return text.length === 0 && lastChangeType === null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getErrorFromValidityState() {\n        const { editorState: externalEditorState, isRequired, maxLength, minLength } = this.props;\n        const { internalEditorState } = this.state;\n\n        // manually check for content length if isRequired is true\n        const editorState: EditorState = internalEditorState || externalEditorState;\n        const { length } = editorState.getCurrentContent().getPlainText().trim();\n\n        if (isRequired && !length) {\n            return messages.valueMissing();\n        }\n\n        if (typeof minLength !== 'undefined' && length < minLength) {\n            return messages.tooShort(minLength);\n        }\n\n        if (typeof maxLength !== 'undefined' && length > maxLength) {\n            return messages.tooLong(maxLength);\n        }\n\n        return null;\n    }\n\n    containerEl: ?HTMLDivElement;\n\n    /**\n     * Event handler called on blur. Triggers validation\n     * @param {SyntheticFocusEvent} event The event object\n     * @returns {void}\n     */\n    handleBlur = (event: SyntheticFocusEvent<>) => {\n        if (\n            this.props.validateOnBlur &&\n            this.containerEl &&\n            event.relatedTarget instanceof Node &&\n            !this.containerEl.contains(event.relatedTarget)\n        ) {\n            this.checkValidity();\n        }\n    };\n\n    handleFocus = (event: SyntheticEvent<>) => {\n        const { onFocus } = this.props;\n\n        if (onFocus) {\n            onFocus(event);\n        }\n    };\n\n    getIsTimestampEntityPresent = (currentContent: ContentState): boolean => {\n        return this.getTimestampLength(currentContent) > 0;\n    };\n\n    /**\n     * Calculates the length of the timestamp entity in the current block\n     * @param {ContentState} currentContent The current content state\n     * @param {ContentBlock} block The content block to analyze\n     * @returns {number} The length of the timestamp entity (including the space after it)\n     */\n    getTimestampLength = (currentContent: ContentState): number => {\n        // $FlowFixMe\n        const block = currentContent?.getFirstBlock();\n        if (!currentContent || !block) {\n            return 0;\n        }\n        let timestampLength = 0;\n        const characterList = block.getCharacterList();\n\n        // get the length of the timestamp entity. This will include the space after the timestamp.\n        for (let i = 0; i < characterList.size; i += 1) {\n            const char = characterList.get(i);\n            if (char && char.getEntity()) {\n                const entity = currentContent.getEntity(char.getEntity());\n                if (entity.getType() === UNEDITABLE_TIMESTAMP_TEXT) {\n                    timestampLength = i + 1;\n                }\n            }\n        }\n        // Include the space after the timestamp\n        return timestampLength ? timestampLength + 1 : 0;\n    };\n\n    /**\n     * Updates editorState, rechecks validity\n     * @param {EditorState} nextEditorState The new editor state to set in the state\n     * @returns {void}\n     */\n    handleChange = (nextEditorState: EditorState) => {\n        const { internalEditorState, isTimestampToggledOn }: State = this.state;\n        const { onChange }: Props = this.props;\n\n        // Check if timestamp entity is still present in the content if video timestamping is enabled.\n        // Update the timestamp prepended state to false if the timestamp entity is no longer present in the editor content\n        // This can happen when the user deletes it with the backspace key.\n        if (this.getIsVideoTimestampEnabled() && isTimestampToggledOn) {\n            const currentContent = nextEditorState.getCurrentContent();\n            const firstBlock = currentContent.getFirstBlock();\n            const timestampLength = this.getTimestampLength(currentContent);\n            const timestampEntityFound = timestampLength > 0;\n            // If timestamp entity is no longer present, update the state\n            if (!timestampEntityFound) {\n                this.setState({ isTimestampToggledOn: false });\n            } else {\n                // Check if the timestamp entity is at the beginning of the content, if not do not update the editor state.\n                // This is to prevent the user from inserting text before the timestamp entity.\n                const characterList = firstBlock.getCharacterList();\n                const firstChar = characterList.get(0);\n                if (firstChar && !firstChar.getEntity()) {\n                    return;\n                }\n            }\n        }\n\n        onChange(nextEditorState);\n\n        if (internalEditorState) {\n            const newState = { internalEditorState: nextEditorState };\n            this.setState(newState);\n        }\n    };\n\n    handleValidityStateUpdateHandler = () => {\n        const { isTouched } = this.state;\n\n        if (!isTouched) {\n            return;\n        }\n\n        const error = this.getErrorFromValidityState();\n\n        this.setState({ error });\n    };\n\n    checkValidity = () => {\n        this.handleValidityStateUpdateHandler();\n    };\n\n    getVideoTimestamp = (): videoTimestamp => {\n        const mediaDashContainer: ?HTMLElement = document.querySelector('.bp-media-dash');\n        // $FlowFixMe\n        const video: ?HTMLVideoElement = mediaDashContainer?.querySelector('video');\n\n        const currentTime = video?.currentTime || 0;\n\n        // We need to get the nubmer of seconds in HMMSS format to display in the timestamp button\n        // and the timestamp in milliseconds to use when the comment form is submitted. This is because\n        // milliseconds are more precise than seconds and we need to make sure that we go to the right frame\n        // when the comment timestamp is clicked in the sidebar.\n        const totalSeconds = Math.floor(currentTime);\n        const timestampToDisplay = convertSecondsToHMMSS(totalSeconds);\n        const timestampInMilliseconds = Math.floor(currentTime * 1000);\n\n        return { timestamp: timestampToDisplay, timestampInMilliseconds };\n    };\n\n    render() {\n        const {\n            className = '',\n            contactsLoaded,\n            editorState: externalEditorState,\n            hideLabel,\n            isDisabled,\n            isRequired,\n            label,\n            description,\n            mentionTriggers,\n            name,\n            onMention,\n            placeholder,\n            selectorRow,\n            startMentionMessage,\n            onReturn,\n            timestampLabel,\n        } = this.props;\n        const { contacts, internalEditorState, error, isTimestampToggledOn: timestampToggledOn } = this.state;\n        const { handleBlur, handleChange, handleFocus, toggleTimestamp } = this;\n        let editorState: EditorState = internalEditorState || externalEditorState;\n\n        // Ensure the editor state has the composite decorator\n        if (editorState.getDecorator() !== this.compositeDecorator) {\n            editorState = EditorState.set(editorState, { decorator: this.compositeDecorator });\n        }\n\n        return (\n            <div\n                ref={containerEl => {\n                    this.containerEl = containerEl;\n                }}\n                className={className}\n            >\n                <FormInput name={name} onValidityStateUpdate={this.handleValidityStateUpdateHandler}>\n                    <DraftJSMentionSelectorCore\n                        contacts={contacts}\n                        contactsLoaded={contactsLoaded}\n                        editorState={editorState}\n                        error={error}\n                        hideLabel={hideLabel}\n                        isDisabled={isDisabled}\n                        isRequired={isRequired}\n                        label={label}\n                        description={description}\n                        mentionTriggers={mentionTriggers}\n                        onBlur={handleBlur}\n                        onChange={handleChange}\n                        onFocus={handleFocus}\n                        onMention={onMention}\n                        onReturn={onReturn}\n                        placeholder={placeholder}\n                        selectorRow={selectorRow}\n                        startMentionMessage={startMentionMessage}\n                    />\n\n                    {isRequired && this.getIsVideoTimestampEnabled() && (\n                        <Toggle\n                            className=\"bcs-CommentTimestamp-toggle\"\n                            data-target-id=\"Toggle-CommentTimestamp\"\n                            // $FlowFixMe - timestampLabel is guaranteed to be defined when getIsVideoTimestampEnabled() returns true\n                            label={timestampLabel}\n                            isOn={timestampToggledOn}\n                            onChange={() => toggleTimestamp(editorState)}\n                        />\n                    )}\n                </FormInput>\n            </div>\n        );\n    }\n}\n\nexport default DraftJSMentionSelector;\n"],"mappings":"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","ignoreList":[]}