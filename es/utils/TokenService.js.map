{"version":3,"file":"TokenService.js","names":["TYPED_ID_FOLDER_PREFIX","TYPED_ID_FILE_PREFIX","error","Error","TokenService","getToken","id","tokenOrTokenFunction","undefined","startsWith","token","read","write","getReadToken","getReadTokens","ids","Array","isArray","promises","map","typedId","tokens","Promise","all","tokenMap","forEach","index","resolve","getWriteToken","cacheTokens","every","itemId"],"sources":["../../src/utils/TokenService.js"],"sourcesContent":["/**\n * @flow\n * @file An example of a token managing service\n * @author Box\n */\n\nimport { TYPED_ID_FOLDER_PREFIX, TYPED_ID_FILE_PREFIX } from '../constants';\nimport type { Token, TokenLiteral } from '../common/types/core';\n\nconst error = new Error(\n    'Bad id or auth token. ID should be typed id like file_123 or folder_123! Token should be a string or function.',\n);\n\nclass TokenService {\n    /**\n     * Function to fetch a single token. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves to either a string/null/undefined token or\n     * a read/write token pair.\n     *\n     * @private\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            (!id.startsWith(TYPED_ID_FOLDER_PREFIX) && !id.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Token is a simple string or null or undefined\n        if (!tokenOrTokenFunction || typeof tokenOrTokenFunction === 'string') {\n            return tokenOrTokenFunction;\n        }\n\n        // Token is a function which returns a promise.\n        // Promise on resolution returns a string/null/undefined token or token pair.\n        const token = await tokenOrTokenFunction(id);\n        if (!token || typeof token === 'string' || (typeof token === 'object' && (token.read || token.write))) {\n            return token;\n        }\n\n        throw error;\n    }\n\n    /**\n     * Gets a string read token.\n     * Defaults to a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {Token} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getReadToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Gets read tokens.\n     *\n     * @public\n     * @param {string|string[]} id - box item typed id(s)\n     * @param {Token} tokenOrTokenFunction - Token to use or token generation function\n     * @return {Promise} Promise that resolves with id to token map\n     */\n    static async getReadTokens(id: string | string[], tokenOrTokenFunction: Token): Promise<Object> {\n        const ids: string[] = Array.isArray(id) ? id : [id];\n        const promises: Promise<?string>[] = ids.map((typedId: string) =>\n            TokenService.getReadToken(typedId, tokenOrTokenFunction),\n        );\n        const tokens: (?string)[] = await Promise.all(promises);\n        const tokenMap = {};\n        tokens.forEach((token, index) => {\n            tokenMap[ids[index]] = token;\n        });\n        return Promise.resolve(tokenMap);\n    }\n\n    /**\n     * Gets a string write token.\n     * Defaults to either the read token or a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getWriteToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.write || token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Function to fetch and cache multiple tokens. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves signifying requested tokens were cached.\n     *\n     * This function however does not return tokens as it is expected to only be used\n     * by the token generator to cache all tokens that may be needed in the future.\n     *\n     * @public\n     * @param {Array<string>} idd - box item typed ids\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise<TokenMap>} that resolves to a token map\n     */\n    static async cacheTokens(ids: Array<string>, tokenOrTokenFunction: Token): Promise<void> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            !ids.every(itemId => itemId.startsWith(TYPED_ID_FOLDER_PREFIX) || itemId.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Only need to fetch and cache multiple tokens when the user supplied token was a\n        // token function. This function should internally cache the tokens for future use.\n        if (typeof tokenOrTokenFunction === 'function') {\n            await tokenOrTokenFunction(ids);\n        }\n\n        return Promise.resolve();\n    }\n}\n\nexport default TokenService;\n"],"mappings":"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","ignoreList":[]}