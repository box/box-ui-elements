{"version":3,"file":"webcrypto.js","names":["sha1","getCrypto","window","crypto","msCrypto","digest","algorithm","buffer","cryptoRef","subtle","Promise","resolve","reject","hashBuffer","arrayBuffer","e","cryptoOperation","name","oncomplete","event","target","result","onerror","getRandomValues","copy","Uint8Array"],"sources":["../../src/utils/webcrypto.js"],"sourcesContent":["import sha1 from 'js-sha1';\n/**\n * @flow\n * @file Wrapper to provide a consistent interface for the webcrypto API\n * @author Box\n */\n\n/**\n * Returns the correct crypto library based on browser implementation\n *\n * @return {Object}\n */\nfunction getCrypto(): Object {\n    return window.crypto || window.msCrypto;\n}\n\n/**\n * Returns a Promise of a digest generated from the\n * hash function and text given as parameters\n *\n * @param {string} algorithm\n * @param {ArrayBuffer} buffer\n * @return {Promise} Promise - resolves with an ArrayBuffer containing the digest result\n */\nfunction digest(algorithm: string, buffer: ArrayBuffer): Promise<ArrayBuffer> {\n    const cryptoRef = getCrypto();\n\n    if (cryptoRef !== window.msCrypto) {\n        return cryptoRef.subtle.digest(algorithm, buffer);\n    }\n\n    // IE11 implements an early version of the SubtleCrypto interface which doesn't use Promises\n    // See http://web-developer-articles.blogspot.com/2015/05/web-cryptography-api.html\n    return new Promise((resolve, reject) => {\n        // Microsoft has dropped support for SHA-1 and so SHA-1 needs to be calculated differently\n        if (algorithm === 'SHA-1') {\n            try {\n                const hashBuffer = sha1.arrayBuffer(buffer);\n                resolve(hashBuffer);\n            } catch (e) {\n                reject(e);\n            }\n        } else {\n            const cryptoOperation = cryptoRef.subtle.digest({ name: algorithm }, buffer);\n\n            cryptoOperation.oncomplete = event => {\n                resolve(event.target.result);\n            };\n            cryptoOperation.onerror = reject;\n        }\n    });\n}\n\n/**\n * Given a buffer/byteArray fills it with random values and returns the same array\n *\n * @param {Uint8Array} buffer\n * @return {Uint8Array}\n */\nfunction getRandomValues(buffer: Uint8Array): Uint8Array {\n    const cryptoRef = getCrypto();\n    const copy = new Uint8Array(buffer);\n    cryptoRef.getRandomValues(copy);\n\n    return copy;\n}\n\nexport { getCrypto, digest, getRandomValues };\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAA,EAAW;EACzB,OAAOC,MAAM,CAACC,MAAM,IAAID,MAAM,CAACE,QAAQ;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,SAAiB,EAAEC,MAAmB,EAAwB;EAC1E,MAAMC,SAAS,GAAGP,SAAS,CAAC,CAAC;EAE7B,IAAIO,SAAS,KAAKN,MAAM,CAACE,QAAQ,EAAE;IAC/B,OAAOI,SAAS,CAACC,MAAM,CAACJ,MAAM,CAACC,SAAS,EAAEC,MAAM,CAAC;EACrD;;EAEA;EACA;EACA,OAAO,IAAIG,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACpC;IACA,IAAIN,SAAS,KAAK,OAAO,EAAE;MACvB,IAAI;QACA,MAAMO,UAAU,GAAGb,IAAI,CAACc,WAAW,CAACP,MAAM,CAAC;QAC3CI,OAAO,CAACE,UAAU,CAAC;MACvB,CAAC,CAAC,OAAOE,CAAC,EAAE;QACRH,MAAM,CAACG,CAAC,CAAC;MACb;IACJ,CAAC,MAAM;MACH,MAAMC,eAAe,GAAGR,SAAS,CAACC,MAAM,CAACJ,MAAM,CAAC;QAAEY,IAAI,EAAEX;MAAU,CAAC,EAAEC,MAAM,CAAC;MAE5ES,eAAe,CAACE,UAAU,GAAGC,KAAK,IAAI;QAClCR,OAAO,CAACQ,KAAK,CAACC,MAAM,CAACC,MAAM,CAAC;MAChC,CAAC;MACDL,eAAe,CAACM,OAAO,GAAGV,MAAM;IACpC;EACJ,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,eAAeA,CAAChB,MAAkB,EAAc;EACrD,MAAMC,SAAS,GAAGP,SAAS,CAAC,CAAC;EAC7B,MAAMuB,IAAI,GAAG,IAAIC,UAAU,CAAClB,MAAM,CAAC;EACnCC,SAAS,CAACe,eAAe,CAACC,IAAI,CAAC;EAE/B,OAAOA,IAAI;AACf;AAEA,SAASvB,SAAS,EAAEI,MAAM,EAAEkB,eAAe","ignoreList":[]}