{"version":3,"file":"Xhr.js","names":["axios","getProp","includes","lowerCase","TokenService","HEADER_ACCEPT","HEADER_ACCEPT_LANGUAGE","HEADER_CLIENT_NAME","HEADER_CLIENT_VERSION","HEADER_CONTENT_TYPE","HTTP_GET","HTTP_POST","HTTP_PUT","HTTP_DELETE","HTTP_OPTIONS","HTTP_HEAD","HTTP_STATUS_CODE_RATE_LIMIT","DEFAULT_UPLOAD_TIMEOUT_MS","MAX_NUM_RETRIES","RETRYABLE_HTTP_METHODS","map","Xhr","constructor","id","clientName","language","token","version","sharedLink","sharedLinkPassword","responseInterceptor","requestInterceptor","retryableStatusCodes","shouldRetry","_defineProperty","error","shouldRetryRequest","retryCount","delay","getExponentialRetryTimeoutInMs","Promise","resolve","reject","retryTimeout","setTimeout","config","then","errorObject","defaultResponseInterceptor","create","axiosSource","CancelToken","source","interceptors","response","use","errorInterceptor","request","status","method","isNetworkError","isRateLimitError","isOtherRetryableError","numRetries","randomizationMs","Math","ceil","random","exponentialMs","getParsedUrl","url","a","document","createElement","href","api","replace","origin","host","hostname","pathname","protocol","hash","port","getHeaders","args","headers","_objectSpread","Accept","BoxApi","itemId","getWriteToken","Authorization","get","params","hdrs","cancelToken","parsedUrl","post","data","put","delete","options","successHandler","errorHandler","catch","uploadFile","progressHandler","withIdleTimeout","idleTimeoutDuration","idleTimeoutHandler","idleTimeout","progressHandlerToUse","idleTimeoutFunc","abort","event","clearTimeout","transformRequest","reqData","reqHeaders","Blob","attributes","formData","FormData","Object","keys","forEach","key","append","onUploadProgress","cancel"],"sources":["../../src/utils/Xhr.js"],"sourcesContent":["/**\n * @flow\n * @file Network utilities\n * @author Box\n */\n\nimport axios from 'axios';\nimport type { $AxiosError, $AxiosXHR } from 'axios';\nimport getProp from 'lodash/get';\nimport includes from 'lodash/includes';\nimport lowerCase from 'lodash/lowerCase';\nimport TokenService from './TokenService';\nimport {\n    HEADER_ACCEPT,\n    HEADER_ACCEPT_LANGUAGE,\n    HEADER_CLIENT_NAME,\n    HEADER_CLIENT_VERSION,\n    HEADER_CONTENT_TYPE,\n    HTTP_GET,\n    HTTP_POST,\n    HTTP_PUT,\n    HTTP_DELETE,\n    HTTP_OPTIONS,\n    HTTP_HEAD,\n    HTTP_STATUS_CODE_RATE_LIMIT,\n} from '../constants';\nimport type { APIOptions, Method, PayloadType, RequestData } from '../common/types/api';\nimport type { StringAnyMap, StringMap, Token } from '../common/types/core';\n\nconst DEFAULT_UPLOAD_TIMEOUT_MS = 120000;\nconst MAX_NUM_RETRIES = 3;\nconst RETRYABLE_HTTP_METHODS = [HTTP_GET, HTTP_OPTIONS, HTTP_HEAD].map(lowerCase);\n\nclass Xhr {\n    id: ?string;\n\n    axios: Axios;\n\n    axiosSource: CancelTokenSource;\n\n    clientName: ?string;\n\n    language: ?string;\n\n    token: Token;\n\n    version: ?string;\n\n    sharedLink: ?string;\n\n    sharedLinkPassword: ?string;\n\n    xhr: XMLHttpRequest;\n\n    responseInterceptor: Function;\n\n    requestInterceptor: ?Function;\n\n    tokenService: TokenService;\n\n    retryCount: number = 0;\n\n    retryableStatusCodes: Array<number>;\n\n    retryTimeout: ?TimeoutID;\n\n    shouldRetry: boolean;\n\n    /**\n     * [constructor]\n     *\n     * @param {Object} options\n     * @param {string} options.id - item id\n     * @param {string} options.clientName - Client Name\n     * @param {string|function} options.token - Auth token\n     * @param {string} [options.language] - Accept-Language header value\n     * @param {string} [options.sharedLink] - Shared link\n     * @param {string} [options.sharedLinkPassword] - Shared link password\n     * @param {string} [options.requestInterceptor] - Request interceptor\n     * @param {string} [options.responseInterceptor] - Response interceptor\n     * @param {number[]} [options.retryableStatusCodes] - Response codes to retry\n     * @param {boolean} [options.shouldRetry] - Should retry failed requests\n     * @return {Xhr} Cache instance\n     */\n    constructor({\n        id,\n        clientName,\n        language,\n        token,\n        version,\n        sharedLink,\n        sharedLinkPassword,\n        responseInterceptor,\n        requestInterceptor,\n        retryableStatusCodes = [HTTP_STATUS_CODE_RATE_LIMIT],\n        shouldRetry = true,\n    }: APIOptions = {}) {\n        this.clientName = clientName;\n        this.id = id;\n        this.language = language;\n        this.responseInterceptor = responseInterceptor || this.defaultResponseInterceptor;\n        this.retryableStatusCodes = retryableStatusCodes;\n        this.sharedLink = sharedLink;\n        this.sharedLinkPassword = sharedLinkPassword;\n        this.shouldRetry = shouldRetry;\n        this.token = token;\n        this.version = version;\n\n        this.axios = axios.create();\n        this.axiosSource = axios.CancelToken.source();\n        this.axios.interceptors.response.use(this.responseInterceptor, this.errorInterceptor);\n\n        if (typeof requestInterceptor === 'function') {\n            this.axios.interceptors.request.use(requestInterceptor);\n        }\n    }\n\n    /**\n     * Default response interceptor which just returns the response\n     *\n     * @param {Object} response - the axios response\n     * @return the response\n     */\n    defaultResponseInterceptor(response: $AxiosXHR<any>) {\n        return response;\n    }\n\n    /**\n     * Determines if a request should be retried\n     *\n     * @param {Object} error - Error object from axios\n     * @return {boolean} true if the request should be retried\n     */\n    shouldRetryRequest(error: $AxiosError<any>): boolean {\n        if (!this.shouldRetry || this.retryCount >= MAX_NUM_RETRIES) {\n            return false;\n        }\n\n        const { response, request, config } = error;\n        // Retry if there is a network error (e.g. ECONNRESET) or rate limited\n        const status = getProp(response, 'status');\n        const method = getProp(config, 'method');\n        const isNetworkError = request && !response;\n        const isRateLimitError = status === HTTP_STATUS_CODE_RATE_LIMIT;\n        const isOtherRetryableError =\n            includes(this.retryableStatusCodes, status) && includes(RETRYABLE_HTTP_METHODS, method);\n        return isNetworkError || isRateLimitError || isOtherRetryableError;\n    }\n\n    /**\n     * Calculate the exponential backoff time with randomized jitter.\n     *\n     * @param {number} numRetries Which retry number this one will be. Must be > 0\n     * @returns {number} The number of milliseconds after which to retry\n     */\n    getExponentialRetryTimeoutInMs(numRetries: number): number {\n        const randomizationMs = Math.ceil(Math.random() * 1000);\n        const exponentialMs = 2 ** (numRetries - 1) * 1000;\n        return exponentialMs + randomizationMs;\n    }\n\n    /**\n     * Error interceptor that wraps the passed in responseInterceptor\n     *\n     * @param {Object} error - Error object from axios\n     * @return {Promise} rejected promise with error info\n     */\n    errorInterceptor = (error: $AxiosError<any>): Promise<any> => {\n        const shouldRetry = this.shouldRetryRequest(error);\n        if (shouldRetry) {\n            this.retryCount += 1;\n            const delay = this.getExponentialRetryTimeoutInMs(this.retryCount);\n            return new Promise((resolve, reject) => {\n                this.retryTimeout = setTimeout(() => {\n                    this.axios(error.config).then(resolve, reject);\n                }, delay);\n            });\n        }\n\n        const errorObject = getProp(error, 'response.data') || error; // In the case of 401, response.data is empty so fall back to error\n        this.responseInterceptor(errorObject);\n\n        return Promise.reject(error);\n    };\n\n    /**\n     * Utility to parse a URL.\n     *\n     * @param {string} url - Url to parse\n     * @return {Object} parsed url\n     */\n    getParsedUrl(url: string) {\n        const a = document.createElement('a');\n        a.href = url;\n        return {\n            api: url.replace(`${a.origin}/2.0`, ''),\n            host: a.host,\n            hostname: a.hostname,\n            pathname: a.pathname,\n            origin: a.origin,\n            protocol: a.protocol,\n            hash: a.hash,\n            port: a.port,\n        };\n    }\n\n    /**\n     * Builds a list of required XHR headers.\n     *\n     * @param {string} [id] - Optional box item id\n     * @param {Object} [args] - Optional existing headers\n     * @return {Object} Headers\n     */\n    async getHeaders(id?: string, args: StringMap = {}) {\n        const headers: StringMap = {\n            Accept: 'application/json',\n            [HEADER_CONTENT_TYPE]: 'application/json',\n            ...args,\n        };\n\n        if (this.language && !headers[HEADER_ACCEPT_LANGUAGE]) {\n            headers[HEADER_ACCEPT_LANGUAGE] = this.language;\n        }\n\n        if (this.sharedLink) {\n            headers.BoxApi = `shared_link=${this.sharedLink}`;\n\n            if (this.sharedLinkPassword) {\n                headers.BoxApi = `${headers.BoxApi}&shared_link_password=${this.sharedLinkPassword}`;\n            }\n        }\n\n        if (this.clientName) {\n            headers[HEADER_CLIENT_NAME] = this.clientName;\n        }\n\n        if (this.version) {\n            headers[HEADER_CLIENT_VERSION] = this.version;\n        }\n\n        // If id is passed in, use that, otherwise default to this.id\n        const itemId = id || this.id || '';\n        const token = await TokenService.getWriteToken(itemId, this.token);\n        if (token) {\n            // Only add a token when there was one found\n            headers.Authorization = `Bearer ${token}`;\n        }\n\n        return headers;\n    }\n\n    /**\n     * HTTP GETs a URL\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Object} [params] - Key-value map of querystring params\n     * @return {Promise} - HTTP response\n     */\n    get({\n        url,\n        id,\n        params = {},\n        headers = {},\n    }: {\n        headers?: StringMap,\n        id?: string,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios.get(url, {\n                cancelToken: this.axiosSource.token,\n                params,\n                headers: hdrs,\n                parsedUrl: this.getParsedUrl(url),\n            }),\n        );\n    }\n\n    /**\n     * HTTP POSTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - xhr type\n     * @return {Promise} - HTTP response\n     */\n    post({\n        url,\n        id,\n        data,\n        params,\n        headers = {},\n        method = HTTP_POST,\n    }: {\n        data: PayloadType,\n        headers?: StringMap,\n        id?: string,\n        method?: Method,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios({\n                url,\n                data,\n                params,\n                method,\n                parsedUrl: this.getParsedUrl(url),\n                headers: hdrs,\n            }),\n        );\n    }\n\n    /**\n     * HTTP PUTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    put({ url, id, data, params, headers = {} }: RequestData): Promise<StringAnyMap> {\n        return this.post({ id, url, data, params, headers, method: HTTP_PUT });\n    }\n\n    /**\n     * HTTP DELETEs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    delete({\n        url,\n        id,\n        data = {},\n        headers = {},\n    }: {\n        data?: StringAnyMap,\n        headers?: StringMap,\n        id?: string,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.post({ id, url, data, headers, method: HTTP_DELETE });\n    }\n\n    /**\n     * HTTP OPTIONs a URL with JSON data.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} data - The non-file post data that should accompany the post\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @return {void}\n     */\n    options({\n        id,\n        url,\n        data,\n        headers = {},\n        successHandler,\n        errorHandler,\n    }: {\n        data: StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        progressHandler?: Function,\n        successHandler: Function,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers)\n            .then(hdrs =>\n                this.axios({\n                    url,\n                    data,\n                    method: HTTP_OPTIONS,\n                    headers: hdrs,\n                })\n                    .then(successHandler)\n                    .catch(errorHandler),\n            )\n            .catch(errorHandler);\n    }\n\n    /**\n     * HTTP POST or PUT a URL with File data. Uses native XHR for progress event.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} [data] - File data and attributes\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - XHR method, supports 'POST' and 'PUT'\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @param {Function} progressHandler - Progress handler\n     * @param {boolean} [withIdleTimeout] - enable idle timeout\n     * @param {number} [idleTimeoutDuration] - idle timeout duration\n     * @param {Function} [idleTimeoutHandler]\n     * @return {void}\n     */\n    uploadFile({\n        id,\n        url,\n        data,\n        headers = {},\n        method = HTTP_POST,\n        successHandler,\n        errorHandler,\n        progressHandler,\n        withIdleTimeout = false,\n        idleTimeoutDuration = DEFAULT_UPLOAD_TIMEOUT_MS,\n        idleTimeoutHandler,\n    }: {\n        data?: ?Blob | ?StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        idleTimeoutDuration?: number,\n        idleTimeoutHandler?: Function,\n        method?: Method,\n        progressHandler: Function,\n        successHandler: Function,\n        url: string,\n        withIdleTimeout?: boolean,\n    }): Promise<any> {\n        return this.getHeaders(id, headers)\n            .then(hdrs => {\n                let idleTimeout;\n                let progressHandlerToUse = progressHandler;\n\n                if (withIdleTimeout) {\n                    // Func that aborts upload and executes timeout callback\n                    const idleTimeoutFunc = () => {\n                        this.abort();\n\n                        if (idleTimeoutHandler) {\n                            idleTimeoutHandler();\n                        }\n                    };\n\n                    idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n\n                    // Progress handler that aborts upload if there has been no progress for >= timeoutMs\n                    progressHandlerToUse = event => {\n                        clearTimeout(idleTimeout);\n                        idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n                        progressHandler(event);\n                    };\n                }\n                this.axios({\n                    url,\n                    data,\n                    transformRequest: (reqData, reqHeaders) => {\n                        // Remove Accept & Content-Type added by getHeaders()\n                        delete reqHeaders[HEADER_ACCEPT];\n                        delete reqHeaders[HEADER_CONTENT_TYPE];\n\n                        if (headers[HEADER_CONTENT_TYPE]) {\n                            reqHeaders[HEADER_CONTENT_TYPE] = headers[HEADER_CONTENT_TYPE];\n                        }\n\n                        // Convert to FormData if needed\n                        if (reqData && !(reqData instanceof Blob) && reqData.attributes) {\n                            const formData = new FormData();\n                            Object.keys(reqData).forEach(key => {\n                                formData.append(key, reqData[key]);\n                            });\n\n                            return formData;\n                        }\n\n                        return reqData;\n                    },\n                    method,\n                    headers: hdrs,\n                    onUploadProgress: progressHandlerToUse,\n                    cancelToken: this.axiosSource.token,\n                })\n                    .then(response => {\n                        clearTimeout(idleTimeout);\n                        successHandler(response);\n                    })\n                    .catch(error => {\n                        clearTimeout(idleTimeout);\n                        errorHandler(error);\n                    });\n            })\n            .catch(errorHandler);\n    }\n\n    /**\n     * Aborts an axios request.\n     *\n     * @return {void}\n     */\n    abort(): void {\n        if (this.retryTimeout) {\n            clearTimeout(this.retryTimeout);\n        }\n        if (this.axiosSource) {\n            this.axiosSource.cancel();\n            this.axiosSource = axios.CancelToken.source();\n        }\n    }\n}\n\nexport default Xhr;\n"],"mappings":"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","ignoreList":[]}