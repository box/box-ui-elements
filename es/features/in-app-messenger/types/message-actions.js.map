{"version":3,"file":"message-actions.js","names":["close","launch","openURL","pushHistory","postToServer","messageActionTypes","messageActions","type"],"sources":["../../../../src/features/in-app-messenger/types/message-actions.js"],"sourcesContent":["// @flow\nimport { type MessageIdentifier } from './message';\n\n/**\n * Define MessageAction\n */\nconst close: 'close' = 'close';\nconst launch: 'launch' = 'launch';\nconst openURL: 'openURL' = 'openURL';\nconst pushHistory: 'pushHistory' = 'pushHistory'; // push history will change href without reloading the app\nconst postToServer: 'postToServer' = 'postToServer';\n\nexport const messageActionTypes = {\n    close,\n    launch,\n    openURL,\n    pushHistory,\n    postToServer,\n};\n\nexport type MessageActionType = $Values<typeof messageActionTypes>;\n\nexport type CloseMessageAction = {|\n    type: typeof close,\n|};\n\nexport type LaunchMessageAction = {|\n    messageIdentifier: MessageIdentifier,\n    type: typeof launch,\n|};\n\nexport type OpenURLMessageAction = {|\n    target: '_blank' | '_self',\n    type: typeof openURL,\n    url: string,\n|};\n\nexport type PushHistoryMessageAction = {|\n    href: string,\n    type: typeof pushHistory,\n|};\n\nexport type PostToServerMessageAction =\n    | {|\n          actionData: {},\n          actionName: string,\n          isProgrammatic: true,\n          type: typeof postToServer,\n      |}\n    | {|\n          actionID: string,\n          isProgrammatic: false,\n          type: typeof postToServer,\n      |};\n\n/**\n * CustomMessageAction can be customized to implement almost any action. An example is provided here:\n *\n * This example assumes you have a template that will send firstName, lastName, email to the either\n * /business-end-point or /personal-end-point based on whether the isBusiness key in global store is true or false.\n * Both end points will return a displayMessage which should be updated UI with through setDisplayMessageAction.\n *\n * The button will be implemented like this:\n *\n * button: {\n *   label: 'click here'\n *   actions: [ (handleMessageActions, messageIdentifier, firstName, lastName, email) => async ( dispatch, getState )\n *   => {\n *      if ( getState()['isBusiness'] ) {\n *        const displayMessage = await post('/business-end-point', { firstName, lastName, email });\n *        dispatch(setDisplayMessageAction(displayMessage));\n *      } else {\n *        const displayMessage = await post('/personal-end-point', { firstName, lastName, email });\n *       dispatch(setDisplayMessageAction(displayMessage));\n *   }]\n * }\n *\n * Here the firstName, lastName, email must be sent from the template\n */\nexport type CustomMessageAction = (\n    handleMessageActions: Function,\n    MessageIdentifier,\n    ...Array<any>\n) => (Function, Function) => any;\n\n/**\n * MessageAction can be an array in which each item will be executed in parallel.\n * All actions are fire and forget except PostToServerMessageAction will make a post request to server and response\n * is treated as MessageAction.\n * If you need any custom behavior, you can implement it through CustomMessageAction\n */\nexport type MessageAction =\n    | CloseMessageAction\n    | OpenURLMessageAction\n    | PushHistoryMessageAction\n    | PostToServerMessageAction\n    | CustomMessageAction;\n\nexport type MessageActions = Array<MessageAction>;\n\nexport const messageActions: {\n    close: CloseMessageAction,\n} = {\n    close: { type: 'close' },\n};\n"],"mappings":"AAGA;AACA;AACA;AACA,MAAMA,KAAc,GAAG,OAAO;AAC9B,MAAMC,MAAgB,GAAG,QAAQ;AACjC,MAAMC,OAAkB,GAAG,SAAS;AACpC,MAAMC,WAA0B,GAAG,aAAa,CAAC,CAAC;AAClD,MAAMC,YAA4B,GAAG,cAAc;AAEnD,OAAO,MAAMC,kBAAkB,GAAG;EAC9BL,KAAK;EACLC,MAAM;EACNC,OAAO;EACPC,WAAW;EACXC;AACJ,CAAC;;AAqCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAUA,OAAO,MAAME,cAEZ,GAAG;EACAN,KAAK,EAAE;IAAEO,IAAI,EAAE;EAAQ;AAC3B,CAAC","ignoreList":[]}