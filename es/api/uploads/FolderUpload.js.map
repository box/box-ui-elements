{"version":3,"file":"FolderUpload.js","names":["getEntryFromDataTransferItem","getFile","getFileAPIOptions","getDataTransferItem","getDataTransferItemAPIOptions","FolderUploadNode","PATH_DELIMITER","FolderUpload","constructor","addFilesToUploadQueue","destinationFolderId","addFolderToUploadQueue","baseAPIOptions","_defineProperty","buildFolderTreeFromWebkitRelativePath","fileList","Array","from","forEach","fileData","file","webkitRelativePath","fileAPIOptions","pathArray","split","slice","length","folder","rootFolderName","createFolderUploadNode","files","push","subTree","folders","pathArryAfterRoot","folderName","index","buildFolderTreeFromDataTransferItem","dataTransferItem","item","apiOptions","entry","name","_objectSpread","upload","errorCallback","successCallback","newFolderId","getFolderId","id","cancel"],"sources":["../../../src/api/uploads/FolderUpload.js"],"sourcesContent":["/**\n * @flow\n * @file Folder upload bootstrapping\n * @author Box\n */\n\nimport {\n    getEntryFromDataTransferItem,\n    getFile,\n    getFileAPIOptions,\n    getDataTransferItem,\n    getDataTransferItemAPIOptions,\n} from '../../utils/uploads';\nimport FolderUploadNode from './FolderUploadNode';\nimport type {\n    UploadDataTransferItemWithAPIOptions,\n    UploadFileWithAPIOptions,\n    UploadFile,\n    FileSystemFileEntry,\n} from '../../common/types/upload';\n\nconst PATH_DELIMITER = '/';\n\nclass FolderUpload {\n    folder: FolderUploadNode;\n\n    files: Array<UploadFile> = [];\n\n    destinationFolderId: string;\n\n    addFilesToUploadQueue: Function;\n\n    addFolderToUploadQueue: Function;\n\n    baseAPIOptions: Object;\n\n    /**\n     * [constructor]\n     *\n     * @param {Function} addFilesToUploadQueue\n     * @param {string} destinationFolderId\n     * @param {Function} addFolderToUploadQueue\n     * @param {Object} baseAPIOptions\n     * @return {void}\n     */\n    constructor(\n        addFilesToUploadQueue: Function,\n        destinationFolderId: string,\n        addFolderToUploadQueue: Function,\n        baseAPIOptions: Object,\n    ): void {\n        this.addFilesToUploadQueue = addFilesToUploadQueue;\n        this.destinationFolderId = destinationFolderId;\n        this.addFolderToUploadQueue = addFolderToUploadQueue;\n        this.baseAPIOptions = baseAPIOptions;\n    }\n\n    /**\n     * Create a folder tree from fileList wekbkitRelativePath\n     *\n     * @public\n     * @param  {Array} Array<UploadFileWithAPIOptions | UploadFile> | FileList\n     * @returns {void}\n     */\n    buildFolderTreeFromWebkitRelativePath(fileList: Array<UploadFileWithAPIOptions | UploadFile> | FileList): void {\n        Array.from(fileList).forEach(fileData => {\n            const file = getFile(fileData);\n            const { webkitRelativePath } = file;\n\n            if (!webkitRelativePath) {\n                return;\n            }\n\n            const fileAPIOptions = getFileAPIOptions(fileData);\n            const pathArray = webkitRelativePath.split(PATH_DELIMITER).slice(0, -1);\n            if (pathArray.length <= 0) {\n                return;\n            }\n\n            // Since only 1 folder tree can be uploaded a time with using webkitRelativePath, the root folder name\n            // of all the files should be the same.\n            if (!this.folder) {\n                const rootFolderName = pathArray[0];\n                this.folder = this.createFolderUploadNode(rootFolderName, fileAPIOptions);\n            }\n\n            // Add file to the root folder\n            if (pathArray.length === 1) {\n                this.folder.files.push(file);\n            }\n\n            let subTree = this.folder.folders;\n            // Walk the path after the root folder\n            const pathArryAfterRoot = pathArray.slice(1);\n            pathArryAfterRoot.forEach((folderName, index) => {\n                // Create new child folder\n                if (!subTree[folderName]) {\n                    subTree[folderName] = this.createFolderUploadNode(folderName, fileAPIOptions);\n                }\n\n                if (index === pathArryAfterRoot.length - 1) {\n                    // end of path, push the file\n                    subTree[folderName].files.push(file);\n                } else {\n                    // walk the tree\n                    subTree = subTree[folderName].folders;\n                }\n            });\n        });\n    }\n\n    /**\n     * Build folder tree from dataTransferItem, which can only represent 1 folder tree\n     *\n     * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} dataTransferItem\n     * @returns {void}\n     */\n    buildFolderTreeFromDataTransferItem(dataTransferItem: DataTransferItem | UploadDataTransferItemWithAPIOptions) {\n        const item = getDataTransferItem(dataTransferItem);\n        const apiOptions = getDataTransferItemAPIOptions(dataTransferItem);\n        const entry = getEntryFromDataTransferItem(item);\n        const { name } = entry;\n\n        this.folder = this.createFolderUploadNode(name, apiOptions, entry);\n    }\n\n    /**\n     * Create a FolderUploadNode instance\n     *\n     * @param {string} name\n     * @param {Object} apiOptions\n     * @param {FileSystemFileEntry} [entry]\n     * @returns {FolderUploadNode}\n     */\n    createFolderUploadNode(name: string, apiOptions: Object, entry?: FileSystemFileEntry): FolderUploadNode {\n        return new FolderUploadNode(\n            name,\n            this.addFilesToUploadQueue,\n            this.addFolderToUploadQueue,\n            apiOptions,\n            {\n                ...this.baseAPIOptions,\n                ...apiOptions,\n            },\n            entry,\n        );\n    }\n\n    /**\n     * Upload folders\n     *\n     * @public\n     * @param {Object} Options\n     * @param {Function} options.errorCallback\n     * @returns {Promise<any>}\n     */\n    async upload({\n        errorCallback,\n        successCallback,\n    }: {\n        errorCallback: Function,\n        successCallback: Function,\n    }): Promise<any> {\n        await this.folder.upload(this.destinationFolderId, errorCallback, true);\n        // If the folder upload failed then a folderID will not be set\n        const newFolderId = this.folder.getFolderId();\n        if (newFolderId) {\n            successCallback([\n                {\n                    id: newFolderId,\n                },\n            ]);\n        }\n    }\n\n    /**\n     * Noop cancel\n     *\n     * @public\n     */\n    cancel() {}\n}\n\nexport default FolderUpload;\n"],"mappings":"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","ignoreList":[]}