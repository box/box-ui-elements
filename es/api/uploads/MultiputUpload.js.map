{"version":3,"file":"MultiputUpload.js","names":["noop","isNaN","getFileLastModifiedAsISONoMSIfPossible","getBoundedExpBackoffRetryDelay","retryNumOfTimes","digest","hexToBase64","createWorker","Browser","DEFAULT_RETRY_DELAY_MS","ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED","HTTP_STATUS_CODE_FORBIDDEN","MS_IN_S","MultiputPart","PART_STATE_UPLOADED","PART_STATE_UPLOADING","PART_STATE_DIGEST_READY","PART_STATE_NOT_STARTED","BaseMultiput","LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR","LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED","LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD","LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED","LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED","LOG_EVENT_TYPE_WEB_WORKER_ERROR","LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR","LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED","MultiputUpload","constructor","options","config","createSession","uploadPart","listParts","commit","abort","logEvent","_defineProperty","data","upload_url","getBaseUploadUrl","splitUrl","split","uploadHost","preflightResponse","isDestroyed","uploadUrl","getBaseUploadUrlFromPreflightResponse","createSessionUrl","includes","parallelism","postData","file_size","file","size","file_name","fileName","fileId","replace","folder_id","folderId","response","xhr","post","url","createSessionSuccessHandler","error","errorData","getErrorResponse","status","createSessionErrorHandler","code","context_info","session","errorCallback","overwrite","resolveConflict","createSessionRetry","sessionErrorHandler","JSON","stringify","createSessionNumRetriesPerformed","retries","consoleLog","sessionUrl","sessionId","get","getSessionSuccessHandler","getSessionErrorHandler","part","numPartsUploading","numPartsUploaded","updateProgress","uploadedBytes","partSize","processNextParts","eventInfo","isResumableUploadsEnabled","nextUploadIndex","firstUnuploadedPartIndex","parts","state","reset","pause","numPartsDigestReady","prevUploadedBytes","newUploadedBytes","totalUploadedBytes","progressCallback","loaded","total","failSessionIfFileChangeDetected","length","fileSha1","commitSession","updateFirstUnuploadedPartIndex","canStartMorePartUploads","uploadNextPart","shouldComputeDigestForNextPart","computeDigestForNextPart","event","type","index","timing","fileDigestTime","duration","sha1","sha1Worker","terminate","buffer","partInformation","offset","postMessage","fileSize","partContents","name","numDigestRetriesPerformed","retryDelayMs","initialRetryDelayMs","maxRetryDelayMs","setTimeout","computeDigestForPart","stats","totalPartReadTime","totalPartDigestTime","totalFileDigestTime","totalPartUploadTime","map","readTime","subtleCryptoTime","uploadTime","getPart","sort","part1","part2","attributes","fileLastModified","content_modified_at","fileDescription","description","clientEventInfo","avg_part_read_time","Math","round","avg_part_digest_time","avg_file_digest_time","avg_part_upload_time","headers","Digest","sessionEndpoints","then","commitSessionSuccessHandler","catch","commitSessionErrorHandler","commitSessionRetry","entries","id","destroy","successCallback","consoleError","commitRetryCount","numPartsNotStarted","numPartsDigestComputing","clientId","numResumeRetries","setFileInfo","conflictCallback","upload","initialFileSize","initialFileLastModified","addEventListener","onWorkerMessage","makePreflightRequest","createSessionTimeout","part_size","session_endpoints","_objectSpread","upload_part","list_parts","log_event","populateParts","resume","getSessionInfo","retryAfterMs","retryAfterSec","parseInt","retryTimeout","forEach","cancel","clearTimeout","commitSessionTimeout","abortSession","uploadOptions","logEventType","logMessage","Error","resolve","reject","err","delete","digestReadahead","i","blob","slice","reader","window","FileReader","startTimestamp","Date","now","readCompleteTimestamp","readFile","sha1ArrayBuffer","btoa","reduce","call","Uint8Array","byte","String","fromCharCode","sendPartToWorker","digestCompleteTimestamp","partDigestTime","onPartDigestError","Number","defaultRetryDelayMs","isPaused","unpause","ceil","currentPartSize","min","getNumPartsUploading","partUploadSuccessHandler","partUploadErrorHandler","push","currentFileSize","currentFileLastModified","changeJSON","oldSize","newSize","oldLastModified","newLastModified","isIE","conflicts","extension","substr","lastIndexOf"],"sources":["../../../src/api/uploads/MultiputUpload.js"],"sourcesContent":["/**\n * @flow\n * @file Multiput upload\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport isNaN from 'lodash/isNaN';\nimport { getFileLastModifiedAsISONoMSIfPossible, getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\nimport { digest } from '../../utils/webcrypto';\nimport hexToBase64 from '../../utils/base64';\nimport createWorker from '../../utils/uploadsSHA1Worker';\nimport Browser from '../../utils/Browser';\nimport {\n    DEFAULT_RETRY_DELAY_MS,\n    ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED,\n    HTTP_STATUS_CODE_FORBIDDEN,\n    MS_IN_S,\n} from '../../constants';\nimport MultiputPart, {\n    PART_STATE_UPLOADED,\n    PART_STATE_UPLOADING,\n    PART_STATE_DIGEST_READY,\n    PART_STATE_NOT_STARTED,\n} from './MultiputPart';\nimport BaseMultiput from './BaseMultiput';\nimport type { MultiputConfig } from '../../common/types/upload';\nimport type { StringAnyMap } from '../../common/types/core';\nimport type { APIOptions } from '../../common/types/api';\n\n// Constants used for specifying log event types.\n\n// This type is a catch-all for create session errors that aren't 5xx's (for which we'll do\n// retries) and aren't specific 4xx's we know how to specifically handle (e.g. out of storage).\nconst LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR = 'create_session_misc_error';\nconst LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED = 'create_session_retries_exceeded';\nconst LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD = 'file_changed_during_upload';\nconst LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED = 'part_upload_retries_exceeded';\nconst LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED = 'commit_retries_exceeded';\nconst LOG_EVENT_TYPE_WEB_WORKER_ERROR = 'web_worker_error';\nconst LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR = 'file_reader_received_not_found_error';\nconst LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED = 'part_digest_retries_exceeded';\n\nclass MultiputUpload extends BaseMultiput {\n    clientId: ?string;\n\n    commitRetryCount: number;\n\n    createSessionNumRetriesPerformed: number;\n\n    destinationFileId: ?string;\n\n    folderId: string;\n\n    fileSha1: ?string;\n\n    firstUnuploadedPartIndex: number;\n\n    initialFileLastModified: ?string;\n\n    initialFileSize: number;\n\n    isResumableUploadsEnabled: boolean;\n\n    successCallback: Function;\n\n    progressCallback: Function;\n\n    options: APIOptions;\n\n    partSize: number;\n\n    parts: Array<MultiputPart>;\n\n    numPartsDigestComputing: number;\n\n    numPartsDigestReady: number;\n\n    numPartsNotStarted: number;\n\n    numPartsUploaded: number;\n\n    numPartsUploading: number;\n\n    numResumeRetries: number;\n\n    sessionEndpoints: Object;\n\n    sessionId: string;\n\n    totalUploadedBytes: number;\n\n    sha1Worker: Worker;\n\n    createSessionTimeout: TimeoutID;\n\n    commitSessionTimeout: TimeoutID;\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {MultiputConfig} [config]\n     */\n    constructor(options: APIOptions, config?: MultiputConfig) {\n        super(\n            options,\n            {\n                createSession: null,\n                uploadPart: null,\n                listParts: null,\n                commit: null,\n                abort: null,\n                logEvent: null,\n            },\n            config,\n        );\n        this.parts = [];\n        this.options = options;\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n        this.clientId = null;\n        this.isResumableUploadsEnabled = false;\n        this.numResumeRetries = 0;\n    }\n\n    /**\n     * Reset values for uploading process.\n     */\n    reset() {\n        this.parts = [];\n        this.fileSha1 = null;\n        this.totalUploadedBytes = 0;\n        this.numPartsNotStarted = 0; // # of parts yet to be processed\n        this.numPartsDigestComputing = 0; // # of parts sent to the digest worker\n        this.numPartsDigestReady = 0; // # of parts with digest finished that are waiting to be uploaded.\n        this.numPartsUploading = 0; // # of parts with upload requests currently inflight\n        this.numPartsUploaded = 0; // # of parts successfully uploaded\n        this.firstUnuploadedPartIndex = 0; // Index of first part that hasn't been uploaded yet.\n        this.createSessionNumRetriesPerformed = 0;\n        this.partSize = 0;\n        this.commitRetryCount = 0;\n        this.numResumeRetries = 0;\n    }\n\n    /**\n     * Set information about file being uploaded\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    setFileInfo({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        // $FlowFixMe\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean | 'error',\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n        this.overwrite = overwrite;\n        this.conflictCallback = conflictCallback;\n        this.fileId = fileId;\n    }\n\n    /**\n     * Upload a given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @return {void}\n     */\n    upload({\n        file,\n        fileDescription,\n        folderId,\n        errorCallback,\n        progressCallback,\n        successCallback,\n        // $FlowFixMe\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileDescription: ?string,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean | 'error',\n        progressCallback?: Function,\n        successCallback?: Function,\n    }): void {\n        this.file = file;\n        this.fileName = this.file.name;\n        // These values are used as part of our (best effort) attempt to abort uploads if we detect\n        // a file change during the upload.\n        this.initialFileSize = this.file.size;\n        this.initialFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        this.folderId = folderId;\n        this.errorCallback = errorCallback || noop;\n        this.progressCallback = progressCallback || noop;\n        this.successCallback = successCallback || noop;\n\n        this.sha1Worker = createWorker();\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.conflictCallback = conflictCallback;\n        this.overwrite = overwrite;\n        this.fileId = fileId;\n        this.fileDescription = fileDescription;\n\n        this.makePreflightRequest();\n    }\n\n    /**\n     * Update uploadHost with preflight response and return the base uploadUrl\n     *\n     * @private\n     * @param {Object} response\n     * @param {Object} [response.data]\n     * @return {string}\n     */\n    getBaseUploadUrlFromPreflightResponse = ({ data }: { data: { upload_url?: string } }) => {\n        if (!data || !data.upload_url) {\n            return this.getBaseUploadUrl();\n        }\n\n        const splitUrl = data.upload_url.split('/');\n        // splitUrl[0] is the protocol (e.g., https:), splitUrl[2] is hostname (e.g., www.box.com)\n        this.uploadHost = `${splitUrl[0]}//${splitUrl[2]}`;\n        return this.getBaseUploadUrl();\n    };\n\n    /**\n     * Creates upload session. If a file ID is supplied, use the Chunked Upload File Version\n     * API to replace the file.\n     *\n     * @private\n     * @return {void}\n     */\n    preflightSuccessHandler = async (preflightResponse: Object): Promise<any> => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const uploadUrl = this.getBaseUploadUrlFromPreflightResponse(preflightResponse);\n        let createSessionUrl = `${uploadUrl}/files/upload_sessions`;\n\n        // Parallelism is currently detrimental to multiput upload performance in Zones, so set it to 1.\n        if (createSessionUrl.includes('fupload-ec2')) {\n            this.config.parallelism = 1;\n        }\n\n        // Set up post body\n        const postData: StringAnyMap = {\n            file_size: this.file.size,\n            file_name: this.fileName,\n        };\n\n        if (this.fileId) {\n            createSessionUrl = createSessionUrl.replace('upload_sessions', `${this.fileId}/upload_sessions`);\n        } else {\n            postData.folder_id = this.folderId;\n        }\n\n        try {\n            const response = await this.xhr.post({\n                url: createSessionUrl,\n                data: postData,\n            });\n            this.createSessionSuccessHandler(response.data);\n        } catch (error) {\n            const errorData = this.getErrorResponse(error);\n\n            if (errorData && errorData.status >= 500 && errorData.status < 600) {\n                this.createSessionErrorHandler(error);\n                return;\n            }\n\n            // Recover from 409 session_conflict.  The server will return the session information\n            // in context_info, so treat it as a success.\n            if (errorData && errorData.status === 409 && errorData.code === 'session_conflict') {\n                this.createSessionSuccessHandler(errorData.context_info.session);\n                return;\n            }\n\n            if (\n                (errorData &&\n                    errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                    errorData.code === ERROR_CODE_UPLOAD_STORAGE_LIMIT_EXCEEDED) ||\n                (errorData.status === HTTP_STATUS_CODE_FORBIDDEN &&\n                    errorData.code === 'access_denied_insufficient_permissions')\n            ) {\n                this.errorCallback(errorData);\n                return;\n            }\n\n            if (errorData && errorData.status === 409) {\n                if (this.overwrite === 'error') {\n                    this.errorCallback(errorData);\n                    return;\n                }\n                this.resolveConflict(errorData);\n                this.createSessionRetry();\n                return;\n            }\n\n            // All other cases get treated as an upload failure.\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_MISC_ERROR, JSON.stringify(error));\n        }\n    };\n\n    /**\n     * Create session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {Error} error\n     * @return {void}\n     */\n    createSessionErrorHandler = (error: Error): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        if (this.createSessionNumRetriesPerformed < this.config.retries) {\n            this.createSessionRetry();\n            return;\n        }\n\n        this.consoleLog('Too many create session failures, failing upload');\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_CREATE_SESSION_RETRIES_EXCEEDED, JSON.stringify(error));\n    };\n\n    /**\n     * Schedule a retry for create session request upon failure\n     *\n     * @private\n     * @return {void}\n     */\n    createSessionRetry(): void {\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.createSessionNumRetriesPerformed,\n        );\n        this.createSessionNumRetriesPerformed += 1;\n        this.consoleLog(`Retrying create session in ${retryDelayMs} ms`);\n        this.createSessionTimeout = setTimeout(this.makePreflightRequest, retryDelayMs);\n    }\n\n    /**\n     * Handles a upload session success response\n     *\n     * @private\n     * @param {Object} data - Upload session creation success data\n     * @return {void}\n     */\n    createSessionSuccessHandler(data: any): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { id, part_size, session_endpoints } = data;\n\n        this.sessionId = id;\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        this.populateParts();\n        this.processNextParts();\n    }\n\n    /**\n     * Resume uploading the given file\n     *\n     *\n     * @param {Object} options\n     * @param {File} options.file\n     * @param {string} options.folderId - Untyped folder id (e.g. no \"folder_\" prefix)\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {string} options.sessionId\n     * @param {Function} [options.errorCallback]\n     * @param {Function} [options.progressCallback]\n     * @param {Function} [options.successCallback]\n     * @param {Function} [options.conflictCallback]\n     * @return {void}\n     */\n    resume({\n        file,\n        folderId,\n        errorCallback,\n        progressCallback,\n        sessionId,\n        successCallback,\n        // $FlowFixMe\n        overwrite = true,\n        conflictCallback,\n        fileId,\n    }: {\n        conflictCallback?: Function,\n        errorCallback?: Function,\n        file: File,\n        fileId: ?string,\n        folderId: string,\n        overwrite?: boolean | 'error',\n        progressCallback?: Function,\n        sessionId: string,\n        successCallback?: Function,\n    }): void {\n        this.setFileInfo({\n            file,\n            folderId,\n            errorCallback,\n            progressCallback,\n            successCallback,\n            conflictCallback,\n            overwrite,\n            fileId,\n        });\n        this.sessionId = sessionId;\n\n        if (!this.sha1Worker) {\n            this.sha1Worker = createWorker();\n        }\n        this.sha1Worker.addEventListener('message', this.onWorkerMessage);\n\n        this.getSessionInfo();\n    }\n\n    /**\n     * Get session information from API.\n     * Uses session info to commit a complete session or continue an in-progress session.\n     *\n     * @private\n     * @return {void}\n     */\n    getSessionInfo = async (): Promise<any> => {\n        const uploadUrl = this.getBaseUploadUrl();\n        const sessionUrl = `${uploadUrl}/files/upload_sessions/${this.sessionId}`;\n        try {\n            const response = await this.xhr.get({ url: sessionUrl });\n            this.getSessionSuccessHandler(response.data);\n        } catch (error) {\n            this.getSessionErrorHandler(error);\n        }\n    };\n\n    /**\n     * Handles a getSessionInfo success and either commits the session or continues to process\n     * the parts that still need to be uploaded.\n     *\n     * @param response\n     * @return {void}\n     */\n    getSessionSuccessHandler(data: any): void {\n        const { part_size, session_endpoints } = data;\n\n        // Set session information gotten from API response\n        this.partSize = part_size;\n        this.sessionEndpoints = {\n            ...this.sessionEndpoints,\n            uploadPart: session_endpoints.upload_part,\n            listParts: session_endpoints.list_parts,\n            commit: session_endpoints.commit,\n            abort: session_endpoints.abort,\n            logEvent: session_endpoints.log_event,\n        };\n\n        this.processNextParts();\n    }\n\n    /**\n     * Handle error from getting upload session.\n     * Restart uploads without valid sessions from the beginning of the upload process.\n     *\n     * @param error\n     * @return {void}\n     */\n    getSessionErrorHandler(error: Error): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const errorData = this.getErrorResponse(error);\n        if (this.numResumeRetries > this.config.retries) {\n            this.errorCallback(errorData);\n            return;\n        }\n\n        if (errorData && errorData.status === 429) {\n            let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n            if (errorData.headers) {\n                const retryAfterSec = parseInt(\n                    errorData.headers['retry-after'] || errorData.headers.get('Retry-After'),\n                    10,\n                );\n                if (!isNaN(retryAfterSec)) {\n                    retryAfterMs = retryAfterSec * MS_IN_S;\n                }\n            }\n            this.retryTimeout = setTimeout(this.getSessionInfo, retryAfterMs);\n            this.numResumeRetries += 1;\n        } else if (errorData && errorData.status >= 400 && errorData.status < 500) {\n            // Restart upload process for errors resulting from invalid/expired session or no permission\n            this.parts.forEach(part => {\n                part.cancel();\n            });\n            this.reset();\n\n            // Abort session\n            clearTimeout(this.createSessionTimeout);\n            clearTimeout(this.commitSessionTimeout);\n            this.abortSession();\n            // Restart the uploading process from the beginning\n            const uploadOptions: Object = {\n                file: this.file,\n                folderId: this.folderId,\n                errorCallback: this.errorCallback,\n                progressCallback: this.progressCallback,\n                successCallback: this.successCallback,\n                overwrite: this.overwrite,\n                fileId: this.fileId,\n            };\n            this.upload(uploadOptions);\n        } else {\n            // Handle internet disconnects (error.request && !error.response) and (!error.request)\n            // Also handle any 500 error messages\n            this.retryTimeout = setTimeout(this.getSessionInfo, 2 ** this.numResumeRetries * MS_IN_S);\n            this.numResumeRetries += 1;\n        }\n    }\n\n    /**\n     * Session error handler.\n     * Retries the create session request or fails the upload.\n     *\n     * @private\n     * @param {?Error} error\n     * @param {string} logEventType\n     * @param {string} [logMessage]\n     * @return {Promise}\n     */\n    async sessionErrorHandler(error: ?Error, logEventType: string, logMessage?: string): Promise<any> {\n        if (!this.isResumableUploadsEnabled) {\n            this.destroy();\n        }\n        const errorData = this.getErrorResponse(error);\n        this.errorCallback(errorData);\n\n        try {\n            if (!this.sessionEndpoints.logEvent) {\n                throw new Error('logEvent endpoint not found');\n            }\n\n            await retryNumOfTimes(\n                (resolve: Function, reject: Function): void => {\n                    this.logEvent(logEventType, logMessage).then(resolve).catch(reject);\n                },\n                this.config.retries,\n                this.config.initialRetryDelayMs,\n            );\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        } catch (err) {\n            if (!this.isResumableUploadsEnabled) {\n                this.abortSession();\n            }\n        }\n    }\n\n    /**\n     * Aborts the upload session\n     *\n     * @private\n     * @return {void}\n     */\n    abortSession(): void {\n        if (this.sha1Worker) {\n            this.sha1Worker.terminate();\n        }\n\n        if (this.sessionEndpoints.abort && this.sessionId) {\n            this.xhr\n                .delete({\n                    url: this.sessionEndpoints.abort,\n                })\n                .then(() => {\n                    this.sessionId = '';\n                });\n        }\n    }\n\n    /**\n     * Part upload success handler\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    partUploadSuccessHandler = (part: MultiputPart): void => {\n        this.numPartsUploading -= 1;\n        this.numPartsUploaded += 1;\n        this.updateProgress(part.uploadedBytes, this.partSize);\n        this.processNextParts();\n    };\n\n    /**\n     * Part upload error handler\n     *\n     * @private\n     * @param {Error} error\n     * @param {string} eventInfo\n     * @return {void}\n     */\n    partUploadErrorHandler = (error: Error, eventInfo: string): void => {\n        this.sessionErrorHandler(error, LOG_EVENT_TYPE_PART_UPLOAD_RETRIES_EXCEEDED, eventInfo);\n        // Pause the rest of the parts.\n        // can't cancel parts because cancel destroys the part and parts are only created in createSession call\n        if (this.isResumableUploadsEnabled) {\n            // Reset uploading process for parts that were in progress when the upload failed\n            let nextUploadIndex = this.firstUnuploadedPartIndex;\n            while (this.numPartsUploading > 0) {\n                const part = this.parts[nextUploadIndex];\n                if (part && part.state === PART_STATE_UPLOADING) {\n                    part.reset();\n                    part.pause();\n\n                    this.numPartsUploading -= 1;\n                    this.numPartsDigestReady += 1;\n                }\n                nextUploadIndex += 1;\n            }\n        }\n    };\n\n    /**\n     * Update upload progress\n     *\n     * @private\n     * @param {number} prevUploadedBytes\n     * @param {number} newUploadedBytes\n     * @return {void}\n     */\n    updateProgress = (prevUploadedBytes: number, newUploadedBytes: number): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.totalUploadedBytes += newUploadedBytes - prevUploadedBytes;\n        this.progressCallback({\n            loaded: this.totalUploadedBytes,\n            total: this.file.size,\n        });\n    };\n\n    /**\n     * Attempts to process more parts, except in the case where everything is done or we detect\n     * a file change (in which case we want to abort and not process more parts).\n     *\n     * @private\n     * @return {void}\n     */\n    processNextParts = (): void => {\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (this.numPartsUploaded === this.parts.length && this.fileSha1) {\n            this.commitSession();\n            return;\n        }\n\n        this.updateFirstUnuploadedPartIndex();\n\n        while (this.canStartMorePartUploads()) {\n            this.uploadNextPart();\n        }\n\n        if (this.shouldComputeDigestForNextPart()) {\n            this.computeDigestForNextPart();\n        }\n    };\n\n    /**\n     * We compute digest for parts one at a time.  This is done for simplicity and also to guarantee that\n     * we send parts in order to the web sha1Worker (which is computing the digest for the entire file).\n     *\n     * @private\n     * @return {boolean} true if there is work to do, false otherwise.\n     */\n    shouldComputeDigestForNextPart(): boolean {\n        return (\n            !this.isDestroyed() &&\n            this.numPartsDigestComputing === 0 &&\n            this.numPartsNotStarted > 0 &&\n            this.numPartsDigestReady < this.config.digestReadahead\n        );\n    }\n\n    /**\n     * Find first part in parts array that doesn't have a digest, and compute its digest.\n\n     * @private\n     * @return {void}\n     */\n    computeDigestForNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n            if (part.state === PART_STATE_NOT_STARTED) {\n                // Update the counters here instead of computeDigestForPart because computeDigestForPart\n                // can get called on retries\n                this.numPartsNotStarted -= 1;\n                this.numPartsDigestComputing += 1;\n                this.computeDigestForPart(part);\n                return;\n            }\n        }\n    }\n\n    /**\n     * Compute digest for this part\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @return {Promise}\n     */\n    async computeDigestForPart(part: MultiputPart): Promise<any> {\n        const blob = this.file.slice(part.offset, part.offset + this.partSize);\n        const reader = new window.FileReader();\n        const startTimestamp = Date.now();\n\n        try {\n            const {\n                buffer,\n                readCompleteTimestamp,\n            }: {\n                buffer: ArrayBuffer,\n                readCompleteTimestamp: number,\n            } = await this.readFile(reader, blob);\n            const sha1ArrayBuffer = await digest('SHA-1', buffer);\n            const sha1 = btoa(\n                [].reduce.call(new Uint8Array(sha1ArrayBuffer), (data, byte) => data + String.fromCharCode(byte), ''),\n            );\n            this.sendPartToWorker(part, buffer);\n\n            part.sha1 = sha1;\n            part.state = PART_STATE_DIGEST_READY;\n            part.blob = blob;\n\n            this.numPartsDigestReady += 1;\n            // This will trigger the next digest computation\n            this.numPartsDigestComputing -= 1;\n            const digestCompleteTimestamp = Date.now();\n\n            part.timing = {\n                partDigestTime: digestCompleteTimestamp - startTimestamp,\n                readTime: readCompleteTimestamp - startTimestamp,\n                subtleCryptoTime: digestCompleteTimestamp - readCompleteTimestamp,\n            };\n\n            this.processNextParts();\n        } catch (error) {\n            this.onPartDigestError(error, part);\n        }\n    }\n\n    /**\n     * Deal with a message from the worker (either a part sha-1 ready, file sha-1 ready, or error).\n     *\n     * @private\n     * @param {object} event\n     * @return {void}\n     */\n    onWorkerMessage = (event: Object) => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { data } = event;\n        if (data.type === 'partDone') {\n            const { part } = data;\n            this.parts[part.index].timing.fileDigestTime = data.duration;\n            this.processNextParts();\n        } else if (data.type === 'done') {\n            this.fileSha1 = hexToBase64(data.sha1);\n            this.sha1Worker.terminate();\n            this.processNextParts();\n        } else if (data.type === 'error') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_WEB_WORKER_ERROR, JSON.stringify(data));\n        }\n    };\n\n    /**\n     * Sends a part to the sha1Worker\n     *\n     * @private\n     * @param {MultiputPart} part\n     * @param {ArrayBuffer} buffer\n     * @return {void}\n     */\n    sendPartToWorker = (part: MultiputPart, buffer: ArrayBuffer): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Don't send entire part since XHR can't be cloned\n        const partInformation = {\n            index: part.index,\n            offset: part.offset,\n            size: part.partSize,\n        };\n        this.sha1Worker.postMessage(\n            {\n                part: partInformation,\n                fileSize: this.file.size,\n                partContents: buffer,\n            },\n            [buffer], // This transfers the ArrayBuffer to the worker context without copying contents.\n        );\n        this.consoleLog(`Part sent to worker: ${JSON.stringify(part)}.}`);\n    };\n\n    /**\n     * Error handler for part digest computation\n     *\n     * @private\n     * @param {Error} error\n     * @param {MultiputPart} part\n     * @return {void}\n     */\n    onPartDigestError = (error: Error, part: MultiputPart): void => {\n        this.consoleLog(`Error computing digest for part ${JSON.stringify(part)}: ${JSON.stringify(error)}`);\n\n        // When a FileReader is processing a file that changes on disk, Chrome reports a 'NotFoundError'\n        // and Safari reports a 'NOT_FOUND_ERR'. (Other browsers seem to allow the reader to keep\n        // going, either with the old version of the new file or the new one.) Since the error name\n        // implies that retrying will not help, we fail the session.\n        if (error.name === 'NotFoundError' || error.name === 'NOT_FOUND_ERR') {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_FILE_READER_RECEIVED_NOT_FOUND_ERROR, JSON.stringify(error));\n            return;\n        }\n\n        if (this.failSessionIfFileChangeDetected()) {\n            return;\n        }\n\n        if (part.numDigestRetriesPerformed >= this.config.retries) {\n            this.sessionErrorHandler(null, LOG_EVENT_TYPE_PART_DIGEST_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            part.numDigestRetriesPerformed,\n        );\n        part.numDigestRetriesPerformed += 1;\n        this.consoleLog(`Retrying digest work for part ${JSON.stringify(part)} in ${retryDelayMs} ms`);\n\n        setTimeout(() => {\n            this.computeDigestForPart(part);\n        }, retryDelayMs);\n    };\n\n    /**\n     * Send a request to commit the upload.\n     *\n     * @private\n     * @return {void}\n     */\n    commitSession = (): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const stats = {\n            totalPartReadTime: 0,\n            totalPartDigestTime: 0,\n            totalFileDigestTime: 0,\n            totalPartUploadTime: 0,\n        };\n\n        const data = {\n            parts: this.parts\n                .map(part => {\n                    stats.totalPartReadTime += part.timing.readTime;\n                    stats.totalPartDigestTime += part.timing.subtleCryptoTime;\n                    stats.totalFileDigestTime += part.timing.fileDigestTime;\n                    stats.totalPartUploadTime += part.timing.uploadTime;\n                    return part.getPart();\n                })\n                .sort((part1, part2) => part1.offset - part2.offset),\n            attributes: {},\n        };\n\n        const fileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n        if (fileLastModified) {\n            data.attributes.content_modified_at = fileLastModified;\n        }\n        if (this.fileDescription) {\n            data.attributes.description = this.fileDescription;\n        }\n\n        const clientEventInfo = {\n            avg_part_read_time: Math.round(stats.totalPartReadTime / this.parts.length),\n            avg_part_digest_time: Math.round(stats.totalPartDigestTime / this.parts.length),\n            avg_file_digest_time: Math.round(stats.totalFileDigestTime / this.parts.length),\n            avg_part_upload_time: Math.round(stats.totalPartUploadTime / this.parts.length),\n        };\n\n        // To make flow stop complaining about this.fileSha1 could potentially be undefined/null\n        const fileSha1: string = (this.fileSha1: any);\n        const headers = {\n            Digest: `sha=${fileSha1}`,\n            'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo),\n        };\n\n        this.xhr\n            .post({ url: this.sessionEndpoints.commit, data, headers })\n            .then(this.commitSessionSuccessHandler)\n            .catch(this.commitSessionErrorHandler);\n    };\n\n    /**\n     * Commit response handler.  Succeeds the upload, retries the commit on 202\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionSuccessHandler = (response: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { status, data } = response;\n\n        if (status === 202) {\n            this.commitSessionRetry(response);\n            return;\n        }\n\n        let { entries } = data;\n        // v2.1 API response format is different from v2.0. v2.1 returns individual upload entry directly inside data,\n        // while v2.0 returns a collection of entries under data.entries\n        if (!entries && data.id) {\n            entries = [data];\n        }\n\n        this.destroy();\n\n        if (this.successCallback && entries) {\n            this.successCallback(entries);\n        }\n    };\n\n    /**\n     * Commit error handler.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} error\n     * @return {void}\n     */\n    commitSessionErrorHandler = (error: Object): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { response } = error;\n\n        if (!response) {\n            // Some random error happened\n            this.consoleError(error);\n            return;\n        }\n\n        if (this.commitRetryCount >= this.config.retries) {\n            this.consoleLog('Too many commit failures, failing upload');\n            this.sessionErrorHandler(error, LOG_EVENT_TYPE_COMMIT_RETRIES_EXCEEDED, JSON.stringify(error));\n            return;\n        }\n\n        this.commitSessionRetry(response);\n    };\n\n    /**\n     * Retry commit.\n     * Retries the commit or fails the multiput session.\n     *\n     * @private\n     * @param {Object} response\n     * @return {void}\n     */\n    commitSessionRetry(response: Object): void {\n        const { status, headers } = response;\n        let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n\n        if (headers) {\n            const retryAfterSec = parseInt(headers['retry-after'], 10);\n\n            if (!Number.isNaN(retryAfterSec)) {\n                retryAfterMs = retryAfterSec * 1000;\n            }\n        }\n\n        const defaultRetryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.commitRetryCount,\n        );\n        // If status is 202 then don't increment the retry count.\n        // In this case, frontend will keep retrying until it gets another status code.\n        // Retry interval = value specified for the Retry-After header in 202 response.\n        if (status !== 202) {\n            this.commitRetryCount += 1;\n        }\n\n        const retryDelayMs = retryAfterMs || defaultRetryDelayMs;\n        this.consoleLog(`Retrying commit in ${retryDelayMs} ms`);\n        this.commitSessionTimeout = setTimeout(this.commitSession, retryDelayMs);\n    }\n\n    /**\n     * Find first part in parts array that we can upload, and upload it.\n     *\n     * @private\n     * @return {void}\n     */\n    uploadNextPart(): void {\n        for (let i = this.firstUnuploadedPartIndex; i < this.parts.length; i += 1) {\n            const part = this.parts[i];\n\n            if (part.state === PART_STATE_DIGEST_READY) {\n                // Update the counters here instead of uploadPart because uploadPart\n                // can get called on retries\n                this.numPartsDigestReady -= 1;\n                this.numPartsUploading += 1;\n                if (part.isPaused) {\n                    part.unpause();\n                } else {\n                    part.upload();\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Checks if upload pipeline is full\n     *\n     * @private\n     * @return {boolean}\n     */\n    canStartMorePartUploads(): boolean {\n        return !this.isDestroyed() && this.numPartsUploading < this.config.parallelism && this.numPartsDigestReady > 0;\n    }\n\n    /**\n     * Functions that walk the parts array get called a lot, so we cache which part we should\n     * start work at to avoid always iterating through entire parts list.\n     *\n     * @private\n     * @return {void}\n     */\n    updateFirstUnuploadedPartIndex(): void {\n        let part = this.parts[this.firstUnuploadedPartIndex];\n        while (part && part.state === PART_STATE_UPLOADED) {\n            this.firstUnuploadedPartIndex += 1;\n            part = this.parts[this.firstUnuploadedPartIndex];\n        }\n    }\n\n    /**\n     * Get number of parts being uploaded\n     *\n     * @return {number}\n     */\n    getNumPartsUploading = (): number => this.numPartsUploading;\n\n    /**\n     * After session is created and we know the part size, populate the parts\n     * array.\n     *\n     * @private\n     * @return {void}\n     */\n    populateParts(): void {\n        this.numPartsNotStarted = Math.ceil(this.file.size / this.partSize);\n\n        for (let i = 0; i < this.numPartsNotStarted; i += 1) {\n            const offset = i * this.partSize;\n            const currentPartSize = Math.min(offset + this.partSize, this.file.size) - offset;\n            const part = new MultiputPart(\n                this.options,\n                i,\n                offset,\n                currentPartSize,\n                this.file.size,\n                this.sessionId,\n                this.sessionEndpoints,\n                this.config,\n                this.getNumPartsUploading,\n                this.partUploadSuccessHandler,\n                this.updateProgress,\n                this.partUploadErrorHandler,\n            );\n            this.parts.push(part);\n        }\n    }\n\n    /**\n     * Fails the session if the file's size or last modified has changed since the upload process\n     * began.\n     *\n     * This ensures that we don't upload a file that has parts from one file version and parts from\n     * another file version.\n     *\n     * This logic + the \"not found\" error logic in onWorkerError() is best effort and will not\n     * detect all possible file changes. This is because of browser differences. For example,\n     * -- In Safari, size and last modified will update when a file changes, and workers will\n     * get \"not found\" errors.\n     * -- In Chrome, size and last modified will update, but not in legacy drag and drop (that\n     * code path constructs a different file object). Workers will still get \"not found\" errors,\n     * though, so we can still detect changes even in legacy drag and drop.\n     * -- In IE 11/Edge, size will update but last modified will not. Workers will not get\n     * \"not found\" errors, but they may get a generic error saying that some bytes failed to be\n     * read.\n     * -- In Firefox, neither last modified nor size will update. Workers don't seem to get errors.\n     * (Not a whole lot we can do here...)\n     *\n     * Unfortunately, alternative solutions to catch more cases don't have a clear ROI (for\n     * example, doing a SHA-1 of the file before and after the upload is very expensive), so\n     * this is the best solution we have. We can revisit this if data shows that we need a better\n     * solution.\n     *\n     * @private\n     * @return {boolean} True if the session was failed, false if no action was taken\n     */\n    failSessionIfFileChangeDetected(): boolean {\n        const currentFileSize = this.file.size;\n        const currentFileLastModified = getFileLastModifiedAsISONoMSIfPossible(this.file);\n\n        if (currentFileSize !== this.initialFileSize || currentFileLastModified !== this.initialFileLastModified) {\n            const changeJSON = JSON.stringify({\n                oldSize: this.initialFileSize,\n                newSize: currentFileSize,\n                oldLastModified: this.initialFileLastModified,\n                newLastModified: currentFileLastModified,\n            });\n            // Leave IE with old behavior and kill upload\n            if (Browser.isIE()) {\n                this.sessionErrorHandler(null, LOG_EVENT_TYPE_FILE_CHANGED_DURING_UPLOAD, changeJSON);\n                return true;\n            }\n            // for evergreen browsers where the file change check does not work, log and continue with upload\n            // https://w3c.github.io/FileAPI/#file-section\n            this.consoleLog(`file properties changed during upload: ${changeJSON}`);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Cancels an upload in progress by cancelling all upload parts.\n     * This cannot be undone or resumed.\n     *\n     * @private\n     * @return {void}\n     */\n    cancel(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Cancel individual upload parts\n        this.parts.forEach(part => {\n            part.cancel();\n        });\n\n        this.parts = [];\n        clearTimeout(this.createSessionTimeout);\n        clearTimeout(this.commitSessionTimeout);\n        this.abortSession();\n        this.destroy();\n    }\n\n    /**\n     * Resolves upload conflict by overwriting or renaming\n     *\n     * @param {Object} response data\n     * @return {Promise}\n     */\n    async resolveConflict(data: Object): Promise<any> {\n        if (this.overwrite && data.context_info) {\n            this.fileId = data.context_info.conflicts.id;\n            return;\n        }\n        if (this.conflictCallback) {\n            this.fileName = this.conflictCallback(this.fileName);\n            return;\n        }\n\n        const extension = this.fileName.substr(this.fileName.lastIndexOf('.')) || '';\n        // foo.txt => foo-1513385827917.txt\n        this.fileName = `${this.fileName.substr(0, this.fileName.lastIndexOf('.'))}-${Date.now()}${extension}`;\n    }\n\n    /**\n     * Returns detailed error response\n     *\n     * @param {Object} error\n     * @return {Object}\n     */\n    getErrorResponse(error: ?Object): Object {\n        if (!error) {\n            return {};\n        }\n\n        const { response } = error;\n        if (!response) {\n            return {};\n        }\n\n        if (response.status === 401) {\n            return response;\n        }\n\n        return response.data;\n    }\n}\n\nexport default MultiputUpload;\n"],"mappings":"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","ignoreList":[]}