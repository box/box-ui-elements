{"version":3,"file":"FolderUploadNode.js","names":["noop","getFileFromEntry","FolderAPI","STATUS_COMPLETE","STATUS_ERROR","ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED","ERROR_CODE_ITEM_NAME_IN_USE","DEFAULT_RETRY_DELAY_MS","MS_IN_S","sleep","CHILD_FOLDER_UPLOAD_CONCURRENCY","MAX_RETRIES","FolderUploadNode","constructor","name","addFilesToUploadQueue","addFolderToUploadQueue","fileAPIOptions","baseAPIOptions","entry","_defineProperty","errorCallback","folders","Object","values","worker","length","folder","pop","upload","folderId","workers","i","push","Promise","all","isRoot","retryCount","buildCurrentFolderFromEntry","errorEncountered","errorCode","data","createFolder","id","error","code","context_info","conflicts","status","retryAfterMs","Math","floor","random","headers","retryAfterHeaderSec","parseInt","get","Number","isNaN","createAndUploadFolder","undefined","folderObject","extension","isFolder","size","progress","files","map","file","options","_objectSpread","uploadInitTimestamp","Date","now","entries","isFile","reader","resolve","readEntries","createFolderUploadNodesFromEntries","readEntry","createReader","parentFolderId","getFolderId","getFormattedFiles","uploadChildFolders","folderAPI","reject","create"],"sources":["../../../src/api/uploads/FolderUploadNode.js"],"sourcesContent":["/**\n * @flow\n * @file Recursively create folder and upload files\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport { getFileFromEntry } from '../../utils/uploads';\nimport FolderAPI from '../Folder';\nimport {\n    STATUS_COMPLETE,\n    STATUS_ERROR,\n    ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED,\n    ERROR_CODE_ITEM_NAME_IN_USE,\n    DEFAULT_RETRY_DELAY_MS,\n    MS_IN_S,\n} from '../../constants';\nimport type {\n    UploadFileWithAPIOptions,\n    FileSystemFileEntry,\n    FolderUploadItem,\n    DirectoryReader,\n} from '../../common/types/upload';\nimport sleep from '../../utils/sleep';\n\nconst CHILD_FOLDER_UPLOAD_CONCURRENCY = 3;\nconst MAX_RETRIES = 3;\n\nclass FolderUploadNode {\n    addFolderToUploadQueue: Function;\n\n    files: Array<File> = [];\n\n    folderId: string;\n\n    folders: Object = {};\n\n    name: string;\n\n    parentFolderId: string;\n\n    addFilesToUploadQueue: Function;\n\n    fileAPIOptions: Object;\n\n    baseAPIOptions: Object;\n\n    entry: ?FileSystemFileEntry;\n\n    /**\n     * [constructor]\n     *\n     * @param {string} name\n     * @param {Function} addFilesToUploadQueue\n     * @param {Function} addFolderToUploadQueue\n     * @returns {void}\n     */\n    constructor(\n        name: string,\n        addFilesToUploadQueue: Function,\n        addFolderToUploadQueue: Function,\n        fileAPIOptions: Object,\n        baseAPIOptions: Object,\n        entry?: FileSystemFileEntry,\n    ) {\n        this.name = name;\n        this.addFilesToUploadQueue = addFilesToUploadQueue;\n        this.addFolderToUploadQueue = addFolderToUploadQueue;\n        this.fileAPIOptions = fileAPIOptions;\n        this.baseAPIOptions = baseAPIOptions;\n        this.entry = entry;\n    }\n\n    /**\n     * Upload a folder\n     *\n     * @public\n     * @param {string} parentFolderId\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    async upload(parentFolderId: string, errorCallback: Function, isRoot: boolean = false) {\n        this.parentFolderId = parentFolderId;\n\n        await this.createAndUploadFolder(errorCallback, isRoot);\n\n        // Check if folder was successfully created before we attempt to upload its contents.\n        if (this.getFolderId()) {\n            this.addFilesToUploadQueue(this.getFormattedFiles(), noop, true);\n            await this.uploadChildFolders(errorCallback);\n        }\n    }\n\n    /**\n     * Upload all child folders\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @returns {Promise}\n     */\n    uploadChildFolders = async (errorCallback: Function) => {\n        // Gets FolderUploadNode values from this.folders key value pairs object\n        // $FlowFixMe\n        const folders: Array<FolderUploadNode> = Object.values(this.folders);\n\n        // Worker function: picks the next folder from the array and uploads until no more folders are available\n        const worker = async () => {\n            while (folders.length > 0) {\n                const folder = folders.pop();\n                if (folder) {\n                    // Await is needed to help ensure rate limit is respected\n                    // eslint-disable-next-line no-await-in-loop\n                    await folder.upload(this.folderId, errorCallback);\n                }\n            }\n        };\n\n        // Spawns up to CHILD_FOLDER_UPLOAD_CONCURRENCY workers that upload folders in parallel until folders array is empty\n        const workers = [];\n        for (let i = 0; i < CHILD_FOLDER_UPLOAD_CONCURRENCY && i < folders.length; i += 1) {\n            workers.push(worker());\n        }\n\n        // Waits for all workers to finish\n        await Promise.all(workers);\n    };\n\n    /**\n     * Create folder and add it to the upload queue\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    createAndUploadFolder = async (errorCallback: Function, isRoot: boolean, retryCount: number = 0) => {\n        await this.buildCurrentFolderFromEntry();\n\n        let errorEncountered = false;\n        let errorCode = '';\n        try {\n            const data = await this.createFolder();\n            this.folderId = data.id;\n        } catch (error) {\n            if (error.code === ERROR_CODE_ITEM_NAME_IN_USE) {\n                this.folderId = error.context_info.conflicts[0].id;\n            } else if (error.status === 429 && retryCount < MAX_RETRIES) {\n                // Set a default exponential backoff delay with a random jitter(0â€“999 ms) to avoid all requests being sent at once\n                // This will be overridden if the Retry-After header is present in the response\n                let retryAfterMs = DEFAULT_RETRY_DELAY_MS * 2 ** retryCount + Math.floor(Math.random() * 1000);\n                if (error.headers) {\n                    const retryAfterHeaderSec = parseInt(\n                        error.headers['retry-after'] || error.headers.get('Retry-After'),\n                        10,\n                    );\n                    if (!Number.isNaN(retryAfterHeaderSec)) {\n                        retryAfterMs = retryAfterHeaderSec * MS_IN_S;\n                    }\n                }\n                await sleep(retryAfterMs);\n                return this.createAndUploadFolder(errorCallback, isRoot, retryCount + 1);\n            } else if (isRoot) {\n                errorCallback(error);\n            } else {\n                // If this is a child folder of the folder being uploaded, this errorCallback will set\n                // an error message on the root folder being uploaded. Set a generic messages saying that a\n                // child has caused the error. The child folder will be tagged with the error message in\n                // the call to this.addFolderToUploadQueue below\n                errorEncountered = true;\n                errorCode = error.code;\n                errorCallback({ code: ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED });\n            }\n        }\n\n        // The root folder has already been added to the upload queue in ContentUploader\n        if (isRoot) {\n            return undefined;\n        }\n\n        const folderObject: FolderUploadItem = {\n            extension: '',\n            name: this.name,\n            status: STATUS_COMPLETE,\n            isFolder: true,\n            size: 1,\n            progress: 100,\n        };\n\n        if (errorEncountered) {\n            folderObject.status = STATUS_ERROR;\n            folderObject.error = { code: errorCode };\n        }\n\n        this.addFolderToUploadQueue(folderObject);\n        return undefined;\n    };\n\n    /**\n     * Format files to Array<UploadFileWithAPIOptions> for upload\n     *\n     * @private\n     * @returns {Array<UploadFileWithAPIOptions>}\n     */\n    getFormattedFiles = (): Array<UploadFileWithAPIOptions> =>\n        this.files.map((file: File) => ({\n            file,\n            options: {\n                ...this.fileAPIOptions,\n                folderId: this.folderId,\n                uploadInitTimestamp: Date.now(),\n            },\n        }));\n\n    /**\n     * Promisify create folder\n     *\n     * @private\n     * @returns {Promise}\n     */\n    createFolder(): Promise<any> {\n        const folderAPI = new FolderAPI({\n            ...this.baseAPIOptions,\n            id: `folder_${this.parentFolderId}`,\n        });\n        return new Promise((resolve, reject) => {\n            folderAPI.create(this.parentFolderId, this.name, resolve, reject);\n        });\n    }\n\n    /**\n     * Create FolderUploadNode instances from entries\n     *\n     * @private\n     * @param {Array<FileSystemFileEntry>} entries\n     * @returns {Promise<any>}\n     */\n    createFolderUploadNodesFromEntries = async (entries: Array<FileSystemFileEntry>): Promise<any> => {\n        await Promise.all(\n            entries.map(async entry => {\n                const { isFile, name } = entry;\n\n                if (isFile) {\n                    const file = await getFileFromEntry(entry);\n                    this.files.push(file);\n                    return;\n                }\n\n                this.folders[name] = new FolderUploadNode(\n                    name,\n                    this.addFilesToUploadQueue,\n                    this.addFolderToUploadQueue,\n                    this.fileAPIOptions,\n                    {\n                        ...this.baseAPIOptions,\n                        ...this.fileAPIOptions,\n                    },\n                    entry,\n                );\n            }),\n        );\n    };\n\n    /**\n     * Recursively read an entry\n     *\n     * @private\n     * @param {DirectoryReader} reader\n     * @param {Function} resolve\n     * @returns {void}\n     */\n    readEntry = (reader: DirectoryReader, resolve: Function) => {\n        reader.readEntries(async entries => {\n            // Quit recursing when there are no remaining entries.\n            if (!entries.length) {\n                resolve();\n                return;\n            }\n\n            await this.createFolderUploadNodesFromEntries(entries);\n\n            this.readEntry(reader, resolve);\n        }, noop);\n    };\n\n    /**\n     * Build current folder from entry\n     *\n     * @private\n     * @returns {Promise<any>}\n     */\n    buildCurrentFolderFromEntry = (): Promise<any> => {\n        if (!this.entry) {\n            return Promise.resolve();\n        }\n\n        return new Promise(resolve => {\n            // $FlowFixMe entry is not empty\n            const reader = this.entry.createReader();\n\n            this.readEntry(reader, resolve);\n        });\n    };\n\n    /**\n     * Returns the folderId\n     * @returns {string}\n     */\n    getFolderId = (): string => {\n        return this.folderId;\n    };\n}\n\nexport default FolderUploadNode;\n"],"mappings":"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","ignoreList":[]}