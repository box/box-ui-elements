{"version":3,"file":"MarkerBasedAPI.js","names":["getTypedFileId","Base","MarkerBasedApi","hasMoreItems","marker","markerGetRequest","id","limit","shouldFetchAll","requestData","isDestroyed","url","getUrl","queryParams","_objectSpread","data","xhr","get","params","entries","concat","nextMarker","next_marker","successHandler","error","errorHandler","markerGet","successCallback","errorCallback"],"sources":["../../src/api/MarkerBasedAPI.js"],"sourcesContent":["/**\n * @flow\n * @file class for Box marker based API's to inherit common functionality from\n * @author Box\n */\nimport { getTypedFileId } from '../utils/file';\nimport Base from './Base';\nimport type { ElementsErrorCallback } from '../common/types/api';\n\ntype Params = {\n    limit: number,\n    marker: string,\n};\n\ntype Data = {\n    entries: Array<any>,\n    limit: number,\n    next_marker: string,\n};\n\nclass MarkerBasedApi extends Base {\n    /**\n     * @property {Data}\n     */\n    data: Data;\n\n    /**\n     * Determines if the API has more items to fetch\n     *\n     * @param {string} marker the marker from the start to start fetching at\n     * @return {boolean} true if there are more items\n     */\n    hasMoreItems(marker: string): boolean {\n        return marker !== null && marker !== '';\n    }\n\n    /**\n     * Helper for get\n     *\n     * @param {string} id the file id\n     * @param {string} marker the marker from the start to start fetching at\n     * @param {number} limit the number of items to fetch\n     * @param {Object} requestData the request query params\n     * @param {boolean} shouldFetchAll true if should get all the pages before calling\n     * @private\n     */\n    async markerGetRequest(\n        id: string,\n        marker: string,\n        limit: number,\n        shouldFetchAll: boolean,\n        requestData: Object = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Make the XHR request\n        try {\n            const url = this.getUrl(id);\n            const queryParams: Params = {\n                ...requestData,\n                marker,\n                limit,\n            };\n\n            const { data }: { data: Data } = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n                params: queryParams,\n            });\n\n            const entries = this.data ? this.data.entries : [];\n            this.data = {\n                ...data,\n                entries: entries.concat(data.entries),\n            };\n            const nextMarker = data.next_marker;\n            if (shouldFetchAll && this.hasMoreItems(nextMarker)) {\n                this.markerGetRequest(id, nextMarker, limit, shouldFetchAll, requestData);\n                return;\n            }\n\n            this.successHandler(this.data);\n        } catch (error) {\n            this.errorHandler(error);\n        }\n    }\n\n    /**\n     * Marker based API get\n     * @param {Object} options\n     * @param {string} options.id the file id\n     * @param {Function} options.successCallback the success callback\n     * @param {Function} options.errorCallback the error callback\n     * @param {string} [options.marker] the marker from the start to start fetching at\n     * @param {number} [options.limit] the number of items to fetch\n     * @param {Object} options.requestData the request query params\n     * @param {boolean} [options.shouldFetchAll] true if should get all the pages before calling the sucessCallback\n     */\n    async markerGet({\n        id,\n        successCallback,\n        errorCallback,\n        marker = '',\n        limit = 1000,\n        requestData,\n        shouldFetchAll = true,\n    }: {\n        errorCallback: ElementsErrorCallback,\n        id: string,\n        limit?: number,\n        marker?: string,\n        requestData?: Object,\n        shouldFetchAll?: boolean,\n        successCallback: Function,\n    }): Promise<void> {\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        return this.markerGetRequest(id, marker, limit, shouldFetchAll, requestData);\n    }\n}\n\nexport default MarkerBasedApi;\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAc,QAAQ,eAAe;AAC9C,OAAOC,IAAI,MAAM,QAAQ;AAczB,MAAMC,cAAc,SAASD,IAAI,CAAC;EAC9B;AACJ;AACA;;EAGI;AACJ;AACA;AACA;AACA;AACA;EACIE,YAAYA,CAACC,MAAc,EAAW;IAClC,OAAOA,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,EAAE;EAC3C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,gBAAgBA,CAClBC,EAAU,EACVF,MAAc,EACdG,KAAa,EACbC,cAAuB,EACvBC,WAAmB,GAAG,CAAC,CAAC,EACX;IACb,IAAI,IAAI,CAACC,WAAW,CAAC,CAAC,EAAE;MACpB;IACJ;;IAEA;IACA,IAAI;MACA,MAAMC,GAAG,GAAG,IAAI,CAACC,MAAM,CAACN,EAAE,CAAC;MAC3B,MAAMO,WAAmB,GAAAC,aAAA,CAAAA,aAAA,KAClBL,WAAW;QACdL,MAAM;QACNG;MAAK,EACR;MAED,MAAM;QAAEQ;MAAqB,CAAC,GAAG,MAAM,IAAI,CAACC,GAAG,CAACC,GAAG,CAAC;QAChDN,GAAG;QACHL,EAAE,EAAEN,cAAc,CAACM,EAAE,CAAC;QACtBY,MAAM,EAAEL;MACZ,CAAC,CAAC;MAEF,MAAMM,OAAO,GAAG,IAAI,CAACJ,IAAI,GAAG,IAAI,CAACA,IAAI,CAACI,OAAO,GAAG,EAAE;MAClD,IAAI,CAACJ,IAAI,GAAAD,aAAA,CAAAA,aAAA,KACFC,IAAI;QACPI,OAAO,EAAEA,OAAO,CAACC,MAAM,CAACL,IAAI,CAACI,OAAO;MAAC,EACxC;MACD,MAAME,UAAU,GAAGN,IAAI,CAACO,WAAW;MACnC,IAAId,cAAc,IAAI,IAAI,CAACL,YAAY,CAACkB,UAAU,CAAC,EAAE;QACjD,IAAI,CAAChB,gBAAgB,CAACC,EAAE,EAAEe,UAAU,EAAEd,KAAK,EAAEC,cAAc,EAAEC,WAAW,CAAC;QACzE;MACJ;MAEA,IAAI,CAACc,cAAc,CAAC,IAAI,CAACR,IAAI,CAAC;IAClC,CAAC,CAAC,OAAOS,KAAK,EAAE;MACZ,IAAI,CAACC,YAAY,CAACD,KAAK,CAAC;IAC5B;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAME,SAASA,CAAC;IACZpB,EAAE;IACFqB,eAAe;IACfC,aAAa;IACbxB,MAAM,GAAG,EAAE;IACXG,KAAK,GAAG,IAAI;IACZE,WAAW;IACXD,cAAc,GAAG;EASrB,CAAC,EAAiB;IACd,IAAI,CAACmB,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAElC,OAAO,IAAI,CAACvB,gBAAgB,CAACC,EAAE,EAAEF,MAAM,EAAEG,KAAK,EAAEC,cAAc,EAAEC,WAAW,CAAC;EAChF;AACJ;AAEA,eAAeP,cAAc","ignoreList":[]}