{"version":3,"file":"Metadata.js","names":["cloneDeep","lodashFilter","flatMap","getProp","isEmpty","keyBy","lodashMap","partition","uniq","uniqueId","getBadItemError","getBadPermissionsError","isUserCorrectableError","getTypedFileId","getTypedFolderId","handleOnAbort","formatMetadataFieldValue","File","HEADER_CONTENT_TYPE","METADATA_SCOPE_ENTERPRISE","METADATA_SCOPE_GLOBAL","METADATA_TEMPLATE_FETCH_LIMIT","METADATA_TEMPLATE_PROPERTIES","METADATA_TEMPLATE_CLASSIFICATION","METADATA_TEMPLATE_SKILLS","METADATA_SUGGESTIONS_CONFIDENCE_EXPERIMENTAL","FIELD_METADATA_SKILLS","CACHE_PREFIX_METADATA","ERROR_CODE_UPDATE_SKILLS","ERROR_CODE_UPDATE_METADATA","ERROR_CODE_CREATE_METADATA","ERROR_CODE_DELETE_METADATA","ERROR_CODE_FETCH_METADATA","ERROR_CODE_FETCH_METADATA_TEMPLATES","ERROR_CODE_FETCH_SKILLS","ERROR_CODE_FETCH_METADATA_OPTIONS","ERROR_CODE_FETCH_METADATA_SUGGESTIONS","ERROR_CODE_EMPTY_METADATA_SUGGESTIONS","TYPE_FILE","ERROR_CODE_FETCH_METADATA_TAXONOMY_NODE","ERROR_CODE_FETCH_METADATA_TAXONOMY","Metadata","getMetadataCacheKey","id","getSkillsCacheKey","getClassificationCacheKey","getMetadataTemplateSchemaCacheKey","templateKey","getMetadataUrl","scope","template","baseUrl","getUrl","getMetadataUrlForFolder","getBaseApiUrl","getMetadataTemplateUrl","getMetadataTemplateUrlForInstance","getMetadataTemplateSchemaUrl","getMetadataTemplateUrlForScope","getCustomPropertiesTemplate","hidden","fields","createEditor","instance","canEdit","data","Object","keys","forEach","key","startsWith","$id","$canEdit","getTaxonomyLevelsForTemplatesUrl","taxonomyPath","getTaxonomyPath","namespace","taxonomyKey","getTaxonomyLevelsForTemplates","metadataTemplates","templates","taxonomyFields","field","type","levels","taxonomy_key","taxonomyPaths","map","filter","Boolean","fetchPromises","result","xhr","get","url","path","error","Error","fetchResults","Promise","all","taxonomyInfo","fieldsToUpdate","restFields","updatedFields","_objectSpread","_ref","displayName","display_name","rest","_objectWithoutProperties","_excluded","concat","getTemplates","instanceId","errorCode","params","limit","e","status","templatesWithTaxonomies","getSchemaByTemplateKey","cache","getCache","has","response","set","getInstances","isMetadataRedesign","instances","getUserAddableTemplates","customPropertiesTemplate","enterpriseTemplates","hasMetadataFeature","isExternallyOwned","userAddableTemplates","extractClassification","classification","find","$template","splice","indexOf","getTemplateForInstance","$scope","t","crossEnterpriseTemplate","getEditors","globalTemplates","editors","push","createTemplateInstance","isInstanceFromTemplate","templateFields","value","$type","getTemplateInstances","templateInstances","getMetadata","file","successCallback","errorCallback","options","permissions","is_externally_owned","errorHandler","forceFetch","unset","successHandler","refreshCache","resolve","filteredInstances","can_upload","metadata","isDestroyed","getSkills","skills","cards","updateSkills","operations","put","headers","merge","getCacheKey","updateMetadata","item","suppressCallbacks","cachedMetadata","editor","findIndex","bulkUpdateMetadata","items","updatePromises","index","message","updateMetadataRedesign","templateInstance","createMetadata","isProperties","post","createMetadataRedesign","fieldsValues","reduce","acc","obj","parseFloat","length","undefined","Array","isArray","option","deleteMetadata","delete","getMetadataSuggestionsUrl","getMetadataSuggestions","confidence","suggestionsResponse","template_key","getMetadataOptionsUrl","fieldKey","getMetadataOptions","level","marker","searchInput","query_text","onlySelectableOptions","ancestorId","ancestor_id","optionsLevel","signal","only_selectable_options","onabort","metadataOptions","getMetadataTaxonomyUrl","getMetadataTaxonomy","metadataTaxonomy","getMetadataTaxonomyNodeUrl","nodeID","includeAncestors","includeAncestorsParam","getMetadataTaxonomyNode","metadataTaxonomyNode"],"sources":["../../src/api/Metadata.js"],"sourcesContent":["/**\n * @flow\n * @file Helper for the Box metadata related API\n * @author Box\n */\n\nimport type { TreeQueryInput } from '@box/combobox-with-api';\nimport cloneDeep from 'lodash/cloneDeep';\nimport lodashFilter from 'lodash/filter';\nimport flatMap from 'lodash/flatMap';\nimport getProp from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport keyBy from 'lodash/keyBy';\nimport lodashMap from 'lodash/map';\nimport partition from 'lodash/partition';\nimport uniq from 'lodash/uniq';\nimport uniqueId from 'lodash/uniqueId';\nimport { getBadItemError, getBadPermissionsError, isUserCorrectableError } from '../utils/error';\nimport { getTypedFileId, getTypedFolderId } from '../utils/file';\nimport { handleOnAbort, formatMetadataFieldValue } from './utils';\nimport File from './File';\nimport {\n    HEADER_CONTENT_TYPE,\n    METADATA_SCOPE_ENTERPRISE,\n    METADATA_SCOPE_GLOBAL,\n    METADATA_TEMPLATE_FETCH_LIMIT,\n    METADATA_TEMPLATE_PROPERTIES,\n    METADATA_TEMPLATE_CLASSIFICATION,\n    METADATA_TEMPLATE_SKILLS,\n    METADATA_SUGGESTIONS_CONFIDENCE_EXPERIMENTAL,\n    FIELD_METADATA_SKILLS,\n    CACHE_PREFIX_METADATA,\n    ERROR_CODE_UPDATE_SKILLS,\n    ERROR_CODE_UPDATE_METADATA,\n    ERROR_CODE_CREATE_METADATA,\n    ERROR_CODE_DELETE_METADATA,\n    ERROR_CODE_FETCH_METADATA,\n    ERROR_CODE_FETCH_METADATA_TEMPLATES,\n    ERROR_CODE_FETCH_SKILLS,\n    ERROR_CODE_FETCH_METADATA_OPTIONS,\n    ERROR_CODE_FETCH_METADATA_SUGGESTIONS,\n    ERROR_CODE_EMPTY_METADATA_SUGGESTIONS,\n    TYPE_FILE,\n    ERROR_CODE_FETCH_METADATA_TAXONOMY_NODE,\n    ERROR_CODE_FETCH_METADATA_TAXONOMY,\n} from '../constants';\n\nimport type { RequestOptions, ElementsErrorCallback, JSONPatchOperations } from '../common/types/api';\nimport type {\n    MetadataTemplateSchemaResponse,\n    MetadataTemplate,\n    MetadataInstanceV2,\n    MetadataEditor,\n    MetadataFields,\n    MetadataSuggestion,\n    MetadataTemplateInstance,\n    MetadataTemplateInstanceField,\n} from '../common/types/metadata';\nimport type { BoxItem } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Metadata extends File {\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getMetadataCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA}${id}`;\n    }\n\n    /**\n     * Creates a key for the skills cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getSkillsCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_skills`;\n    }\n\n    /**\n     * Creates a key for the classification cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getClassificationCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_classification`;\n    }\n\n    /**\n     * Creates a key for the metadata template schema cache\n     *\n     * @param {string} templateKey - template key\n     * @return {string} key\n     */\n    getMetadataTemplateSchemaCacheKey(templateKey: string): string {\n        return `${CACHE_PREFIX_METADATA}template_schema_${templateKey}`;\n    }\n\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box file id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n    getMetadataUrl(id: string, scope?: string, template?: string): string {\n        const baseUrl = `${this.getUrl(id)}/metadata`;\n        if (scope && template) {\n            return `${baseUrl}/${scope}/${template}`;\n        }\n        return baseUrl;\n    }\n\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box folder id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n    getMetadataUrlForFolder(id: string, scope?: string, template?: string): string {\n        const baseUrl = `${this.getBaseApiUrl()}/folders/${id}/metadata`;\n        if (scope && template) {\n            return `${baseUrl}/${scope}/${template}`;\n        }\n        return baseUrl;\n    }\n\n    /**\n     * API URL for metadata templates for a scope\n     *\n     * @param {string} scope - metadata scope\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_templates`;\n    }\n\n    /**\n     * API URL for metadata template for an instance\n     *\n     * @param {string} id - metadata instance id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForInstance(id: string): string {\n        return `${this.getMetadataTemplateUrl()}?metadata_instance_id=${id}`;\n    }\n\n    /**\n     * API URL for getting metadata template schema by template key\n     *\n     * @param {string} templateKey - metadata template key\n     * @return {string} API url for getting template schema by template key\n     */\n    getMetadataTemplateSchemaUrl(templateKey: string): string {\n        return `${this.getMetadataTemplateUrl()}/enterprise/${templateKey}/schema`;\n    }\n\n    /**\n     * API URL for metadata templates\n     *\n     * @param {string} scope - metadata scope or id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForScope(scope: string): string {\n        return `${this.getMetadataTemplateUrl()}/${scope}`;\n    }\n\n    /**\n     * Returns the custom properties template\n     *\n     * @return {Object} template for custom properties\n     */\n    getCustomPropertiesTemplate(): MetadataTemplate {\n        return {\n            id: uniqueId('metadata_template_'),\n            scope: METADATA_SCOPE_GLOBAL,\n            templateKey: METADATA_TEMPLATE_PROPERTIES,\n            hidden: false,\n            fields: [],\n        };\n    }\n\n    /**\n     * Utility to create editors from metadata instances\n     * and metadata templates.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - is instance editable\n     * @return {Object} metadata editor\n     */\n    createEditor(instance: MetadataInstanceV2, template: MetadataTemplate, canEdit: boolean): MetadataEditor {\n        const data: MetadataFields = {};\n        Object.keys(instance).forEach(key => {\n            if (!key.startsWith('$')) {\n                // $FlowFixMe\n                data[key] = instance[key];\n            }\n        });\n\n        return {\n            template,\n            instance: {\n                id: instance.$id,\n                canEdit: instance.$canEdit && canEdit,\n                data,\n            },\n        };\n    }\n\n    /**\n     * API URL for taxonomies levels for templates\n     *\n     * @param {string} taxonomyPath - taxonomy path\n     * @return {string} base url for files\n     */\n    getTaxonomyLevelsForTemplatesUrl(taxonomyPath: string): string {\n        return `${this.getBaseApiUrl()}/${taxonomyPath}`;\n    }\n\n    /**\n     * Returns taxonomy path for API calls and level mapping\n     *\n     * @param {string} namespace\n     * @param {string} taxonomyKey\n     * @returns {string}\n     */\n    getTaxonomyPath(namespace?: string, taxonomyKey?: string): string | null {\n        if (!namespace || !taxonomyKey) {\n            return null;\n        }\n        return `metadata_taxonomies/${namespace}/${taxonomyKey}`;\n    }\n\n    /**\n     *\n     * @param {Array<MetadataTemplate>} metadataTemplates\n     * @param {string} id\n     * @returns {Array<MetadataTemplate>}\n     */\n    async getTaxonomyLevelsForTemplates(\n        metadataTemplates: Array<MetadataTemplate>,\n        id: string,\n    ): Promise<Array<MetadataTemplate>> {\n        const templates = cloneDeep(metadataTemplates);\n\n        const taxonomyFields = flatMap(templates, template =>\n            lodashFilter(\n                template.fields,\n                field => field.type === 'taxonomy' && !field.levels && (field.taxonomyKey || field.taxonomy_key),\n            ),\n        );\n\n        if (isEmpty(taxonomyFields)) {\n            return templates;\n        }\n\n        const taxonomyPaths = uniq(\n            taxonomyFields\n                .map(field => this.getTaxonomyPath(field.namespace, field.taxonomyKey || field.taxonomy_key))\n                .filter(Boolean),\n        );\n\n        const fetchPromises = taxonomyPaths.map(async taxonomyPath => {\n            try {\n                const result = await this.xhr.get({\n                    url: this.getTaxonomyLevelsForTemplatesUrl(taxonomyPath),\n                    id: getTypedFileId(id),\n                });\n                return {\n                    path: taxonomyPath,\n                    levels: result.data.levels || [],\n                };\n            } catch (error) {\n                throw new Error(`Failed to fetch taxonomy for path: ${taxonomyPath}`);\n            }\n        });\n\n        const fetchResults = await Promise.all(fetchPromises);\n\n        const taxonomyInfo = keyBy(fetchResults, 'path');\n\n        return lodashMap(templates, template => {\n            if (!template.fields) return template;\n\n            const [fieldsToUpdate, restFields] = partition(\n                template.fields,\n                field => field.type === 'taxonomy' && !field.levels,\n            );\n\n            if (isEmpty(fieldsToUpdate)) return template;\n\n            const updatedFields = lodashMap(fieldsToUpdate, field => {\n                const taxonomyPath = this.getTaxonomyPath(field.namespace, field.taxonomyKey || field.taxonomy_key);\n                const levels = taxonomyInfo[taxonomyPath]?.levels || [];\n\n                const taxonomyKey = field.taxonomyKey || field.taxonomy_key;\n\n                delete field.taxonomy_key;\n\n                return {\n                    ...field,\n                    levels: lodashMap(levels, ({ displayName, display_name, ...rest }) => ({\n                        ...rest,\n                        displayName: displayName || display_name,\n                    })),\n                    taxonomyKey,\n                };\n            });\n\n            return {\n                ...template,\n                fields: restFields.concat(updatedFields),\n            };\n        });\n    }\n\n    /**\n     * Gets metadata templates for enterprise\n     *\n     * @param {string} id - file id\n     * @param {string} scope - metadata scope\n     * @param {string|void} [instanceId] - metadata instance id\n     * @return {Object} array of metadata templates\n     */\n    async getTemplates(id: string, scope: string, instanceId?: string): Promise<Array<MetadataTemplate>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TEMPLATES;\n        let templates = {};\n        const url = instanceId\n            ? this.getMetadataTemplateUrlForInstance(instanceId)\n            : this.getMetadataTemplateUrlForScope(scope);\n\n        try {\n            templates = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n                params: {\n                    limit: METADATA_TEMPLATE_FETCH_LIMIT, // internal hard limit is 500\n                },\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n\n        templates = getProp(templates, 'data.entries', []);\n        const templatesWithTaxonomies = await this.getTaxonomyLevelsForTemplates(templates, id);\n\n        return templatesWithTaxonomies;\n    }\n\n    /**\n     * Gets metadata template schema by template key\n     *\n     * @param {string} templateKey - template key\n     * @return {Promise} Promise object of metadata template\n     */\n    async getSchemaByTemplateKey(templateKey: string): Promise<MetadataTemplateSchemaResponse> {\n        const cache: APICache = this.getCache();\n        const key = this.getMetadataTemplateSchemaCacheKey(templateKey);\n\n        // Return cached value if it exists\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n\n        // Fetch from API if not cached\n        const url = this.getMetadataTemplateSchemaUrl(templateKey);\n        const response = await this.xhr.get({ url });\n\n        // Cache the response\n        cache.set(key, response);\n\n        return response;\n    }\n\n    /**\n     * Gets metadata instances for a Box file\n     *\n     * @param {string} id - file id\n     * @param {boolean} isMetadataRedesign - feature flag\n     * @return {Object} array of metadata instances\n     */\n    async getInstances(id: string, isMetadataRedesign: boolean = false): Promise<Array<MetadataInstanceV2>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        const baseUrl = this.getMetadataUrl(id);\n        const url = isMetadataRedesign ? `${baseUrl}?view=hydrated` : baseUrl;\n        let instances = {};\n        try {\n            instances = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n        return getProp(instances, 'data.entries', []);\n    }\n\n    /**\n     * Returns a list of templates that can be added by the user.\n     * For collabed files, only custom properties is allowed.\n     *\n     * @return {Object} template for custom properties\n     */\n    getUserAddableTemplates(\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        hasMetadataFeature: boolean,\n        isExternallyOwned?: boolean,\n    ): Array<MetadataTemplate> {\n        let userAddableTemplates: Array<MetadataTemplate> = [];\n        if (hasMetadataFeature) {\n            userAddableTemplates = isExternallyOwned\n                ? [customPropertiesTemplate]\n                : [customPropertiesTemplate].concat(enterpriseTemplates);\n        }\n        // Only templates that are not hidden and not classification\n        return userAddableTemplates.filter(\n            template => !template.hidden && template.templateKey !== METADATA_TEMPLATE_CLASSIFICATION,\n        );\n    }\n\n    /**\n     * Extracts classification for different representation in the UI.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @return {Array} metadata instances without classification\n     */\n    extractClassification(id: string, instances: Array<MetadataInstanceV2>): Array<MetadataInstanceV2> {\n        const classification = instances.find(instance => instance.$template === METADATA_TEMPLATE_CLASSIFICATION);\n        if (classification) {\n            instances.splice(instances.indexOf(classification), 1);\n            const cache: APICache = this.getCache();\n            const key = this.getClassificationCacheKey(id);\n            cache.set(key, classification);\n        }\n        return instances;\n    }\n\n    /**\n     * Finds template for a given metadata instance.\n     *\n     * @param {string} id - Box file id\n     * @param {Object} instance - metadata instance\n     * @param {Array} templates - metadata templates\n     * @return {Object|undefined} template for metadata instance\n     */\n    async getTemplateForInstance(\n        id: string,\n        instance: MetadataInstanceV2,\n        templates: Array<MetadataTemplate>,\n    ): Promise<?MetadataTemplate> {\n        const instanceId = instance.$id;\n        const templateKey = instance.$template;\n        const scope = instance.$scope;\n        let template = templates.find(t => t.templateKey === templateKey && t.scope === scope);\n\n        // Enterprise scopes are always enterprise_XXXXX\n        if (!template && scope.startsWith(METADATA_SCOPE_ENTERPRISE)) {\n            // If the template does not exist, it can be a template from another\n            // enterprise because the user is viewing a collaborated file.\n            const crossEnterpriseTemplate = await this.getTemplates(id, scope, instanceId);\n            // The API always returns an array of at most one item\n            template = crossEnterpriseTemplate[0]; // eslint-disable-line\n        }\n\n        return template;\n    }\n\n    /**\n     * Creates and returns metadata editors.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit - metadata editability\n     * @return {Array} metadata editors\n     */\n    async getEditors(\n        id: string,\n        instances: Array<MetadataInstanceV2>,\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        globalTemplates: Array<MetadataTemplate>,\n        canEdit: boolean,\n    ): Promise<Array<MetadataEditor>> {\n        // All usable templates for metadata instances\n        const templates: Array<MetadataTemplate> = [customPropertiesTemplate].concat(\n            enterpriseTemplates,\n            globalTemplates,\n        );\n\n        // Create editors from each instance\n        const editors: Array<MetadataEditor> = [];\n        await Promise.all(\n            instances.map(async instance => {\n                const template: ?MetadataTemplate = await this.getTemplateForInstance(id, instance, templates);\n                if (template) {\n                    editors.push(this.createEditor(instance, template, canEdit));\n                }\n            }),\n        );\n        return editors;\n    }\n\n    /**\n     * Utility to concat instance and template into one entity.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - can user edit item\n     * @return {Object} metadata template instance\n     */\n    createTemplateInstance(\n        instance: MetadataInstanceV2,\n        template: MetadataTemplate,\n        canEdit: boolean,\n    ): MetadataTemplateInstance {\n        const fields: MetadataTemplateInstanceField[] = [];\n\n        // templateKey is unique identifier for the template,\n        // but its value is set to 'properties' if instance was created using Custom Metadata option instead of template\n        const isInstanceFromTemplate = template.templateKey !== METADATA_TEMPLATE_PROPERTIES;\n        if (isInstanceFromTemplate) {\n            // Get Metadata Fields for Instances created from predefined template\n            const templateFields = template.fields || [];\n            templateFields.forEach(field => {\n                const value = formatMetadataFieldValue(field, instance[field.key]);\n\n                fields.push({\n                    ...field,\n                    value,\n                });\n            });\n        } else {\n            // Get Metadata Fields for Custom Instances\n            Object.keys(instance).forEach(key => {\n                if (!key.startsWith('$')) {\n                    fields.push({\n                        key,\n                        type: 'string',\n                        value: instance[key],\n                    });\n                }\n            });\n        }\n\n        return {\n            canEdit: instance.$canEdit && canEdit,\n            displayName: template.displayName,\n            hidden: template.hidden,\n            id: template.id,\n            fields,\n            scope: template.scope,\n            templateKey: template.templateKey,\n            type: instance.$type,\n        };\n    }\n\n    /**\n     * Creates and returns metadata entities.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit\n     * @return {Array} metadata editors\n     */\n    async getTemplateInstances(\n        id: string,\n        instances: Array<MetadataInstanceV2>,\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        globalTemplates: Array<MetadataTemplate>,\n        canEdit: boolean,\n    ): Promise<Array<MetadataTemplateInstance>> {\n        // Get all usable templates for metadata instances\n        const templates: Array<MetadataTemplate> = [customPropertiesTemplate].concat(\n            enterpriseTemplates,\n            globalTemplates,\n        );\n\n        // Create Metadata Template Instance from each instance\n        const templateInstances: Array<MetadataTemplateInstance> = [];\n\n        await Promise.all(\n            instances.map(async instance => {\n                const template: ?MetadataTemplate = await this.getTemplateForInstance(id, instance, templates);\n                if (template) {\n                    templateInstances.push(this.createTemplateInstance(instance, template, canEdit));\n                }\n            }),\n        );\n\n        return templateInstances;\n    }\n\n    /**\n     * API for getting metadata editors\n     *\n     * @param {Object} file\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} hasMetadataFeature - metadata feature check\n     * @param {Object} options - fetch options\n     * @param {boolean} isMetadataRedesign - is Metadata Sidebar redesigned\n     * @return {Promise}\n     */\n    async getMetadata(\n        file: BoxItem,\n        successCallback: ({\n            editors: Array<MetadataEditor>,\n            templateInstances: Array<MetadataTemplateInstance>,\n            templates: Array<MetadataTemplate>,\n        }) => void,\n        errorCallback: ElementsErrorCallback,\n        hasMetadataFeature: boolean,\n        options: RequestOptions = {},\n        isMetadataRedesign: boolean = false,\n    ): Promise<void> {\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Check for valid file object.\n        // Need to eventually check for upload permission.\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getMetadataCacheKey(id);\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the cached value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        try {\n            const customPropertiesTemplate: MetadataTemplate = this.getCustomPropertiesTemplate();\n            const [instances, globalTemplates, enterpriseTemplates] = await Promise.all([\n                this.getInstances(id, isMetadataRedesign),\n                this.getTemplates(id, METADATA_SCOPE_GLOBAL),\n                hasMetadataFeature ? this.getTemplates(id, METADATA_SCOPE_ENTERPRISE) : Promise.resolve([]),\n            ]);\n\n            // Filter out classification\n            const filteredInstances = this.extractClassification(id, instances);\n\n            const templateInstances = isMetadataRedesign\n                ? await this.getTemplateInstances(\n                      id,\n                      filteredInstances,\n                      customPropertiesTemplate,\n                      enterpriseTemplates,\n                      globalTemplates,\n                      !!permissions.can_upload,\n                  )\n                : [];\n            const editors = !isMetadataRedesign\n                ? await this.getEditors(\n                      id,\n                      filteredInstances,\n                      customPropertiesTemplate,\n                      enterpriseTemplates,\n                      globalTemplates,\n                      !!permissions.can_upload,\n                  )\n                : [];\n\n            const metadata = {\n                editors,\n                templateInstances,\n                templates: this.getUserAddableTemplates(\n                    customPropertiesTemplate,\n                    enterpriseTemplates,\n                    hasMetadataFeature,\n                    is_externally_owned,\n                ),\n            };\n\n            cache.set(key, metadata);\n\n            if (!this.isDestroyed()) {\n                this.successHandler(metadata);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets skills for file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getSkills(\n        file: BoxItem,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        forceFetch: boolean = false,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_FETCH_SKILLS;\n        const { id }: BoxItem = file;\n        if (!id) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getSkillsCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the Cache value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            return;\n        }\n\n        // The file object may already have skills in it\n        let skills = {\n            data: getProp(file, FIELD_METADATA_SKILLS),\n        };\n\n        try {\n            if (!skills.data) {\n                skills = await this.xhr.get({\n                    url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                    id: getTypedFileId(id),\n                });\n            }\n\n            if (!this.isDestroyed()) {\n                const cards = skills.data.cards || [];\n                cache.set(key, cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching skills on a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} field - Metadata field to patch\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateSkills(\n        file: BoxItem,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_SKILLS;\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cards = metadata.data.cards || [];\n                this.merge(this.getCacheKey(id), FIELD_METADATA_SKILLS, metadata.data);\n                this.getCache().set(this.getSkillsCacheKey(id), cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching metadata on item (file/folder)\n     *\n     * @param {BoxItem} item - File/Folder object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} suppressCallbacks - Boolean to decide whether suppress callbacks or not\n     * @return {Promise}\n     */\n    async updateMetadata(\n        item: BoxItem,\n        template: MetadataTemplate,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        suppressCallbacks?: boolean,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        if (!suppressCallbacks) {\n            // Only set callbacks when we intend to invoke them for this call\n            // so that callers performing bulk operations can suppress per-item callbacks\n            this.successCallback = successCallback;\n            this.errorCallback = errorCallback;\n        }\n\n        const { id, permissions, type } = item;\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n\n        if (!canEdit) {\n            this.errorHandler(getBadPermissionsError());\n            return;\n        }\n\n        try {\n            const metadata = await this.xhr.put({\n                url:\n                    type === 'file'\n                        ? this.getMetadataUrl(id, template.scope, template.templateKey)\n                        : this.getMetadataUrlForFolder(id, template.scope, template.templateKey),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: type === 'file' ? getTypedFileId(id) : getTypedFolderId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                if (cachedMetadata && cachedMetadata.editors) {\n                    cachedMetadata.editors.splice(\n                        cachedMetadata.editors.findIndex(({ instance }) => instance.id === editor.instance.id),\n                        1,\n                        editor,\n                    );\n                }\n                if (!suppressCallbacks) {\n                    this.successHandler(editor);\n                }\n            }\n        } catch (e) {\n            if (suppressCallbacks) {\n                // Let the caller decide how to handle errors (e.g., aggregate for bulk operations)\n                throw e;\n            }\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for bulk patching metadata on items (file/folder)\n     *\n     * @param {BoxItem[]} items - File/Folder object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations for each item\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async bulkUpdateMetadata(\n        items: BoxItem[],\n        template: MetadataTemplate,\n        operations: JSONPatchOperations[],\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const updatePromises = items.map(async (item, index) => {\n                try {\n                    // Suppress per-item callbacks; aggregate outcome at the bulk level only\n                    await this.updateMetadata(item, template, operations[index], successCallback, errorCallback, true);\n                } catch (e) {\n                    // Re-throw to be caught by Promise.all and handled once below\n                    throw new Error(`Failed to update metadata: ${e.message || e}`);\n                }\n            });\n\n            await Promise.all(updatePromises);\n\n            if (!this.isDestroyed()) {\n                this.successHandler();\n            }\n        } catch (e) {\n            if (!this.isDestroyed()) {\n                this.errorHandler(e);\n            }\n        }\n    }\n\n    /**\n     * API for patching metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} templateInstance - Metadata template instance\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateMetadataRedesign(\n        file: BoxItem,\n        templateInstance: MetadataTemplateInstance,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n\n        if (!canEdit) {\n            this.errorHandler(getBadPermissionsError());\n            return;\n        }\n\n        try {\n            await this.xhr.put({\n                url: this.getMetadataUrl(id, templateInstance.scope, templateInstance.templateKey),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                if (cachedMetadata && cachedMetadata.templateInstances) {\n                    cachedMetadata.templateInstances.splice(\n                        cachedMetadata.templateInstances.findIndex(\n                            instance =>\n                                instance.scope === templateInstance.scope &&\n                                instance.templateKey === templateInstance.templateKey,\n                        ),\n                        1,\n                        templateInstance,\n                    );\n                }\n                this.successHandler();\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async createMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_CREATE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n        const isProperties =\n            template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n\n        if (!canEdit || (is_externally_owned && !isProperties)) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.post({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                id: getTypedFileId(id),\n                data: {},\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                cachedMetadata.editors.push(editor);\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata Redesign template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async createMetadataRedesign(\n        file: BoxItem,\n        template: MetadataTemplateInstance,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_CREATE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n        const isProperties =\n            template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n\n        if (!canEdit || (is_externally_owned && !isProperties)) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const fieldsValues = template.fields.reduce((acc, obj) => {\n                let { value } = obj;\n\n                // API does not accept string for float type\n                if (obj.type === 'float' && value) {\n                    value = parseFloat(obj.value);\n                }\n\n                // API does not accept empty string for enum type\n                if (obj.type === 'enum' && value && value.length === 0) {\n                    value = undefined;\n                }\n\n                // API expects values as an array of strings\n                if (obj.type === 'taxonomy' && value && Array.isArray(value)) {\n                    value = value.map(option => option.value);\n                }\n\n                acc[obj.key] = value;\n\n                return acc;\n            }, {});\n\n            const metadata = await this.xhr.post({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                id: getTypedFileId(id),\n                data: fieldsValues,\n            });\n\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n\n                const templateInstance = { ...template, type: metadata.data.$type };\n                cachedMetadata.templateInstances.push(templateInstance);\n                this.successHandler(templateInstance);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for deleting metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} template - Metadata template key\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param isMetadataRedesign\n     * @return {Promise}\n     */\n    async deleteMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        isMetadataRedesign: boolean = false,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_DELETE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { scope, templateKey }: MetadataTemplate = template;\n        const { id, permissions }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            await this.xhr.delete({\n                url: this.getMetadataUrl(id, scope, templateKey),\n                id: getTypedFileId(id),\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const metadata = cache.get(key);\n                if (isMetadataRedesign) {\n                    metadata.templateInstances.splice(\n                        metadata.templateInstances.findIndex(\n                            instance => instance.scope === scope && instance.templateKey === templateKey,\n                        ),\n                        1,\n                    );\n                } else {\n                    metadata.editors.splice(\n                        metadata.editors.findIndex(\n                            editor => editor.template.scope === scope && editor.template.templateKey === templateKey,\n                        ),\n                        1,\n                    );\n                }\n                this.successHandler();\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API URL for metadata suggestions\n     *\n     * @return {string} url for metadata suggestions\n     */\n    getMetadataSuggestionsUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_instances/suggestions`;\n    }\n\n    /**\n     * Gets suggestions for possible metadata key-value pairs for the given item\n     *\n     * @param {string} id - Id of the item to pull metadata from\n     * @param {string} type - Type of item. Only \"file” is supported.\n     * @param {string} scope - The metadata template scope\n     * @param {string} templateKey - The metadata template key to apply\n     * @param {string} confidence - The confidence level the suggestion must surpass. Only “experimental” is supported.\n     * @return {Array<MetadataSuggestion>} array of metadata templates\n     */\n    async getMetadataSuggestions(\n        id: string,\n        type: typeof TYPE_FILE,\n        scope: string,\n        templateKey: string,\n        confidence: typeof METADATA_SUGGESTIONS_CONFIDENCE_EXPERIMENTAL = METADATA_SUGGESTIONS_CONFIDENCE_EXPERIMENTAL,\n    ): Promise<Array<MetadataSuggestion>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_SUGGESTIONS;\n\n        if (!id || type !== TYPE_FILE) {\n            throw getBadItemError();\n        }\n\n        if (!scope) {\n            throw new Error('Missing scope');\n        }\n\n        if (!templateKey) {\n            throw new Error('Missing templateKey');\n        }\n\n        if (confidence !== METADATA_SUGGESTIONS_CONFIDENCE_EXPERIMENTAL) {\n            throw new Error(`Invalid confidence level: \"${confidence}\"`);\n        }\n\n        let suggestionsResponse = {};\n        try {\n            suggestionsResponse = await this.xhr.get({\n                url: this.getMetadataSuggestionsUrl(),\n                id: getTypedFileId(id),\n                params: {\n                    item: `${type}_${id}`,\n                    scope,\n                    template_key: templateKey,\n                    confidence,\n                },\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n\n        if (!isEmpty(suggestionsResponse) && getProp(suggestionsResponse, 'data.suggestions').length === 0) {\n            this.errorCode = ERROR_CODE_EMPTY_METADATA_SUGGESTIONS;\n            throw new Error('No suggestions found.');\n        }\n\n        return getProp(suggestionsResponse, 'data.suggestions', []);\n    }\n\n    /**\n     * Build URL for metadata options associated to a taxonomy field.\n     *\n     * @param scope\n     * @param templateKey\n     * @param fieldKey\n     * @returns {`${string}/metadata_templates/${string}/${string}/fields/${string}/options`}\n     */\n    getMetadataOptionsUrl(scope: string, templateKey: string, fieldKey: string): string {\n        return `${this.getBaseApiUrl()}/metadata_templates/${scope}/${templateKey}/fields/${fieldKey}/options`;\n    }\n\n    /**\n     * Gets options associated with a taxonomy field.\n     *\n     * @param id\n     * @param scope\n     * @param templateKey\n     * @param fieldKey\n     * @param level\n     * @param options\n     * @returns {Promise<MetadataOptions>}\n     */\n    async getMetadataOptions(\n        id: string,\n        scope: string,\n        templateKey: string,\n        fieldKey: string,\n        level: number,\n        options: TreeQueryInput,\n    ) {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_OPTIONS;\n\n        if (!id) {\n            throw getBadItemError();\n        }\n\n        if (!scope) {\n            throw new Error('Missing scope');\n        }\n\n        if (!templateKey) {\n            throw new Error('Missing templateKey');\n        }\n\n        if (!fieldKey) {\n            throw new Error('Missing fieldKey');\n        }\n\n        // 0 is a valid level value\n        if (!level && level !== 0) {\n            throw new Error('Missing level');\n        }\n\n        const {\n            marker,\n            searchInput: query_text,\n            onlySelectableOptions,\n            ancestorId: ancestor_id,\n            level: optionsLevel,\n            signal,\n        } = options;\n\n        const params: {} = {\n            ...(marker ? { marker } : {}),\n            ...(query_text ? { query_text } : {}),\n            ...(optionsLevel ? { level: optionsLevel } : {}),\n            ...(ancestor_id ? { ancestor_id } : {}),\n            ...(onlySelectableOptions !== undefined ? { only_selectable_options: !!onlySelectableOptions } : {}),\n            limit: 100,\n        };\n\n        const url = this.getMetadataOptionsUrl(scope, templateKey, fieldKey);\n\n        if (signal) {\n            signal.onabort = () => handleOnAbort(this.xhr);\n        }\n\n        const metadataOptions = await this.xhr.get({\n            url,\n            id: getTypedFileId(id),\n            params,\n        });\n\n        return getProp(metadataOptions, 'data', {});\n    }\n\n    /**\n     * Build URL for metadata taxonomy.\n     *\n     * @param {string} scope\n     * @param {string} taxonomyKey\n     * @returns {`${string}/metadata_taxonomies/${string}/${string}`}\n     */\n    getMetadataTaxonomyUrl(scope: string, taxonomyKey: string): string {\n        return `${this.getBaseApiUrl()}/metadata_taxonomies/${scope}/${taxonomyKey}`;\n    }\n\n    /**\n     * Gets taxonomy associated with a taxonomy key.\n     *\n     * @param {number} id\n     * @param {string} scope\n     * @param {string} taxonomyKey\n     * @param {string} nodeID\n     * @returns {Promise<MetadataTaxonomy>}\n     */\n    async getMetadataTaxonomy(id: string, scope: string, taxonomyKey: string) {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TAXONOMY;\n\n        if (!id) {\n            throw getBadItemError();\n        }\n\n        if (!scope) {\n            throw new Error('Missing scope');\n        }\n\n        if (!taxonomyKey) {\n            throw new Error('Missing taxonomyKey');\n        }\n\n        const url = this.getMetadataTaxonomyUrl(scope, taxonomyKey);\n\n        const metadataTaxonomy = await this.xhr.get({ url, id: getTypedFileId(id) });\n\n        return getProp(metadataTaxonomy, 'data', {});\n    }\n\n    /**\n     * Build URL for metadata taxonomies associated to a taxonomy node ID.\n     *\n     * @param {string} scope\n     * @param {string} taxonomyKey\n     * @param {string} nodeID\n     * @param {boolean} includeAncestors\n     * @returns {`${string}/metadata_taxonomies/${string}/${string}/nodes/${string}`}\n     */\n    getMetadataTaxonomyNodeUrl(\n        scope: string,\n        taxonomyKey: string,\n        nodeID: string,\n        includeAncestors?: boolean = false,\n    ): string {\n        const includeAncestorsParam = includeAncestors ? '?include-ancestors=true' : '';\n\n        return `${this.getBaseApiUrl()}/metadata_taxonomies/${scope}/${taxonomyKey}/nodes/${nodeID}${includeAncestorsParam}`;\n    }\n\n    /**\n     * Gets info associated with a taxonomy node.\n     *\n     * @param {number} id\n     * @param {string} scope\n     * @param {string} taxonomyKey\n     * @param {string} nodeID\n     * @param {boolean} includeAncestors\n     * @returns {Promise<MetadataTaxonomyNode>}\n     */\n    async getMetadataTaxonomyNode(\n        id: string,\n        scope: string,\n        taxonomyKey: string,\n        nodeID: string,\n        includeAncestors?: boolean,\n    ) {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TAXONOMY_NODE;\n\n        if (!id) {\n            throw getBadItemError();\n        }\n\n        if (!nodeID) {\n            throw new Error('Missing nodeID');\n        }\n\n        if (!scope) {\n            throw new Error('Missing scope');\n        }\n\n        if (!taxonomyKey) {\n            throw new Error('Missing taxonomyKey');\n        }\n\n        const url = this.getMetadataTaxonomyNodeUrl(scope, taxonomyKey, nodeID, includeAncestors);\n\n        const metadataTaxonomyNode = await this.xhr.get({ url, id: getTypedFileId(id) });\n\n        return getProp(metadataTaxonomyNode, 'data', {});\n    }\n}\n\nexport default Metadata;\n"],"mappings":"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","ignoreList":[]}